// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2016-2020 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.encoding {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding.tlv;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// A Tlv0_2WireFormat implements the WireFormat interface for encoding and
	/// decoding with the NDN-TLV wire format, version 0.2.
	/// </summary>
	///
	public class Tlv0_2WireFormat : Tlv0_3WireFormat {
		/// <summary>
		/// Encode interest using NDN-TLV and return the encoding.
		/// </summary>
		///
		/// <param name="interest">The Interest object to encode.</param>
		/// <param name="signedPortionBeginOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <param name="signedPortionEndOffset">name component and ends just before the final name component (which is assumed to be a signature for a signed interest).</param>
		/// <returns>A Blob containing the encoding.</returns>
		public override Blob encodeInterest(Interest interest,
				int[] signedPortionBeginOffset, int[] signedPortionEndOffset) {
			if (!interest.getDidSetCanBePrefix_() && !net.named_data.jndn.encoding.Tlv0_3WireFormat.didCanBePrefixWarning_) {
				System.Console.Out
						.WriteLine("WARNING: The default CanBePrefix will change. See Interest.setDefaultCanBePrefix() for details.");
				net.named_data.jndn.encoding.Tlv0_3WireFormat.didCanBePrefixWarning_ = true;
			}
	
			if (interest.hasApplicationParameters())
				// The application has specified a format v0.3 field. As we transition to
				// format v0.3, encode as format v0.3 even though the application default
				// is Tlv0_2WireFormat.
				return net.named_data.jndn.encoding.Tlv0_3WireFormat.encodeInterestV03(interest, signedPortionBeginOffset,
						signedPortionEndOffset);
	
			TlvEncoder encoder = new TlvEncoder(256);
			int saveLength = encoder.getLength();
	
			// Encode backwards.
			if (interest.getForwardingHint().size() > 0) {
				if (interest.getSelectedDelegationIndex() >= 0)
					throw new Exception(
							"An Interest may not have a selected delegation when encoding a forwarding hint");
				if (interest.hasLink())
					throw new Exception(
							"An Interest may not have a link object when encoding a forwarding hint");
	
				int forwardingHintSaveLength = encoder.getLength();
				net.named_data.jndn.encoding.Tlv0_3WireFormat.encodeDelegationSet(interest.getForwardingHint(), encoder);
				encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.ForwardingHint, encoder.getLength()
						- forwardingHintSaveLength);
			}
	
			encoder.writeOptionalNonNegativeIntegerTlv(net.named_data.jndn.encoding.tlv.Tlv.SelectedDelegation,
					interest.getSelectedDelegationIndex());
			try {
				Blob linkWireEncoding = interest.getLinkWireEncoding(this);
				if (!linkWireEncoding.isNull())
					// Encode the entire link as is.
					encoder.writeBuffer(linkWireEncoding.buf());
			} catch (EncodingException ex) {
				throw new Exception(ex.Message);
			}
	
			encoder.writeOptionalNonNegativeIntegerTlvFromDouble(
					net.named_data.jndn.encoding.tlv.Tlv.InterestLifetime,
					interest.getInterestLifetimeMilliseconds());
	
			// Encode the Nonce as 4 bytes.
			if (interest.getNonce().size() == 0) {
				// This is the most common case. Generate a nonce.
				ByteBuffer nonce = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(4);
				random_.nextBytes(nonce.array());
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, nonce);
			} else if (interest.getNonce().size() < 4) {
				ByteBuffer nonce_0 = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(4);
				// Copy existing nonce bytes.
				nonce_0.put(interest.getNonce().buf());
	
				// Generate random bytes for remaining bytes in the nonce.
				for (int i = 0; i < 4 - interest.getNonce().size(); ++i)
					nonce_0.put((byte) random_.Next());
	
				nonce_0.flip();
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, nonce_0);
			} else if (interest.getNonce().size() == 4)
				// Use the nonce as-is.
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, interest.getNonce().buf());
			else {
				// Truncate.
				ByteBuffer nonce_1 = interest.getNonce().buf();
				// buf() returns a new ByteBuffer, so we can change its limit.
				nonce_1.limit(nonce_1.position() + 4);
				encoder.writeBlobTlv(net.named_data.jndn.encoding.tlv.Tlv.Nonce, nonce_1);
			}
	
			net.named_data.jndn.encoding.Tlv0_3WireFormat.encodeSelectors(interest, encoder);
			int[] tempSignedPortionBeginOffset = new int[1];
			int[] tempSignedPortionEndOffset = new int[1];
			net.named_data.jndn.encoding.Tlv0_3WireFormat.encodeName(interest.getName(), tempSignedPortionBeginOffset,
					tempSignedPortionEndOffset, encoder);
			int signedPortionBeginOffsetFromBack = encoder.getLength()
					- tempSignedPortionBeginOffset[0];
			int signedPortionEndOffsetFromBack = encoder.getLength()
					- tempSignedPortionEndOffset[0];
	
			encoder.writeTypeAndLength(net.named_data.jndn.encoding.tlv.Tlv.Interest, encoder.getLength()
					- saveLength);
			signedPortionBeginOffset[0] = encoder.getLength()
					- signedPortionBeginOffsetFromBack;
			signedPortionEndOffset[0] = encoder.getLength()
					- signedPortionEndOffsetFromBack;
	
			return new Blob(encoder.getOutput(), false);
		}
	
		/// <summary>
		/// Get a singleton instance of a Tlv0_2WireFormat.  To always use the
		/// preferred version NDN-TLV, you should use TlvWireFormat.get().
		/// </summary>
		///
		/// <returns>The singleton instance.</returns>
		public static Tlv0_2WireFormat get() {
			return instance_;
		}
	
		private static readonly Random random_ = new Random();
		private static Tlv0_2WireFormat instance_ = new Tlv0_2WireFormat();
	}
}
