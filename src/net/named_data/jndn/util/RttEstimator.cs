// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2015-2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.util {
	
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// RTTEstimator is a utility class which uses Round-Trip times to calculates retransmission timeout
	/// This class implements the "Mean-Deviation" RTT estimator, as discussed in RFC 6298,
	/// with the modifications to RTO calculation described in RFC 7323 Appendix G.
	/// </summary>
	///
	
	public class RttEstimator {
	
		public class Options {
	
			public Options() {
				this.alpha = 0.125d;
				this.beta = 0.25d;
				this.initialRto = 1000.0d;
				this.minRto = 200.0d;
				this.maxRto = 60000.0d;
				this.k = 4;
				this.rtoBackoffMultiplier = 2;
			}
			/// <summary>
			/// weight of exponential moving average for smoothed RTT
			/// </summary>
			///
			public double alpha;
			/// <summary>
			/// weight of exponential moving average for RTT variation
			/// </summary>
			///
			public double beta;
			/// <summary>
			/// initial RTO value in milliseconds
			/// </summary>
			///
			public double initialRto;
			/// <summary>
			/// lower bound of RTO in milliseconds
			/// </summary>
			///
			public double minRto;
			/// <summary>
			/// upper bound of RTO in milliseconds
			/// </summary>
			///
			public double maxRto;
			/// <summary>
			/// RTT vaiation multiplier used when calculating RTO
			/// </summary>
			///
			public int k;
			/// <summary>
			/// RTO multiplier used in backoff operation
			/// </summary>
			///
			public int rtoBackoffMultiplier;
	
		}
	
		/// <summary>
		/// Creates an RTT estimator.
		/// Configures the RTT estimator with the default parameters.
		/// </summary>
		///
		public RttEstimator() : this(new Options()) {
		}
	
		/// <summary>
		/// Create an RTT Estimator
		/// Configures the RTT Estimator
		/// </summary>
		///
		/// <param name="options_">Parameters for configuration.</param>
		internal RttEstimator(RttEstimator.Options  options_) {
			this.sRtt_ = System.Double.NaN;
			this.rttVar_ = System.Double.NaN;
			this.rto_ = 0;
			this.rttMin_ = System.Double.MaxValue;
			this.rttMax_ = System.Double.MinValue;
			this.rttAvg_ = 0.0d;
			this.nRttSamples_ = 0;
			this.options_ = options_;
			rto_ = options_.initialRto;
		}
	
		/// <summary>
		/// Record a new RTT measurement.
		/// </summary>
		///
		/// <param name="rtt">the sampled RTT</param>
		/// <param name="nExpectedSamples">refer to Appendix G of RFC 7323 for details. NOTE: Do not call this function with RTT samples from retransmitted Interests (per Karn's algorithm).</param>
		internal void addMeasurement(double rtt, int nExpectedSamples) {
			if (nRttSamples_ == 0) { // first measurement
				sRtt_ = rtt;
				rttVar_ = sRtt_ / 2;
			} else {
				double alpha_0 = options_.alpha / nExpectedSamples;
				double beta_1 = options_.beta / nExpectedSamples;
				rttVar_ = (1 - beta_1) * rttVar_ + beta_1 * Math.Abs(sRtt_ - rtt);
				sRtt_ = (1 - alpha_0) * sRtt_ + alpha_0 * rtt;
			}
	
			rto_ = sRtt_ + options_.k * rttVar_;
			rto_ = clamp(rto_, options_.minRto, options_.maxRto);
	
			rttAvg_ = (nRttSamples_ * rttAvg_ + rtt) / (nRttSamples_ + 1);
			rttMax_ = Math.Max(rtt,rttMax_);
			rttMin_ = Math.Max(rtt,rttMin_);
			nRttSamples_++;
		}
	
		/// <summary>
		/// Backoff RTO by a factor of Options.rtoBackoffMultiplier.
		/// </summary>
		///
		internal void backoffRto() {
			rto_ = clamp(rto_ * options_.rtoBackoffMultiplier, options_.minRto,
					options_.maxRto);
		}
	
		private static double clamp(double val, double min, double max) {
			return Math.Max(min,Math.Min(max,val));
		}
	
		/// <summary>
		/// Returns the estimated RTO value.
		/// </summary>
		///
		internal double getEstimatedRto() {
			return rto_;
		}
	
		/// <summary>
		/// Returns the minimum RTT observed.
		/// </summary>
		///
		internal double getMinRtt() {
			return rttMin_;
		}
	
		/// <summary>
		/// Returns the maximum RTT observed.
		/// </summary>
		///
		internal double getMaxRtt() {
			return rttMax_;
		}
	
		/// <summary>
		/// Returns the average RTT.
		/// </summary>
		///
		internal double getAvgRtt() {
			return rttAvg_;
		}
	
		private readonly RttEstimator.Options  options_;
		private double sRtt_; // smoothed round-trip time
		private double rttVar_; // round-trip time variation
		private double rto_; // retransmission timeout
		private double rttMin_;
		private double rttMax_;
		private double rttAvg_;
		private long nRttSamples_; // number of RTT samples
	}
}
