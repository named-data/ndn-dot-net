// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2014-2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn {
	
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.security;
	using net.named_data.jndn.transport;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// The Face class provides the main methods for NDN communication.
	/// </summary>
	///
	public class Face {
		/// <summary>
		/// Create a new Face for communication with an NDN hub with the given
		/// Transport object and connectionInfo.
		/// </summary>
		///
		/// <param name="transport">A Transport object used for communication.</param>
		/// <param name="connectionInfo"></param>
		public Face(Transport transport, Transport.ConnectionInfo connectionInfo) {
			this.commandKeyChain_ = null;
			this.commandCertificateName_ = new Name();
			node_ = new Node(transport, connectionInfo);
		}
	
		/// <summary>
		/// Create a new Face for communication with an NDN hub at host:port using the
		/// default TcpTransport.
		/// </summary>
		///
		/// <param name="host">The host of the NDN hub.</param>
		/// <param name="port">The port of the NDN hub.</param>
		public Face(String host, int port) {
			this.commandKeyChain_ = null;
			this.commandCertificateName_ = new Name();
			node_ = new Node(new TcpTransport(), new TcpTransport.ConnectionInfo(
					host, port));
		}
	
		/// <summary>
		/// Create a new Face for communication with an NDN hub at host using the
		/// default port 6363 and the default TcpTransport.
		/// </summary>
		///
		/// <param name="host">The host of the NDN hub.</param>
		public Face(String host) {
			this.commandKeyChain_ = null;
			this.commandCertificateName_ = new Name();
			node_ = new Node(new TcpTransport(), new TcpTransport.ConnectionInfo(
					host, 6363));
		}
	
		/// <summary>
		/// Create a new Face for communication with an NDN hub at "localhost" using the
		/// default port 6363 and the default TcpTransport.
		/// </summary>
		///
		public Face() {
			this.commandKeyChain_ = null;
			this.commandCertificateName_ = new Name();
			node_ = new Node(new TcpTransport(), new TcpTransport.ConnectionInfo(
					"localhost", 6363));
		}
	
		/// <summary>
		/// Enable or disable Interest loopback. If Interest loopback is enabled, then
		/// an Interest to expressInterest is also sent to each of the matching
		/// OnInterest callbacks that the application gave to registerPrefix or
		/// setInterestFilter, and a Data that the application gives to putData can
		/// satisfy pending Interests. This way one part of an application can do
		/// Interest/Data exchange with another part through the same Face. Interest
		/// loopback is disabled by default.
		/// </summary>
		///
		/// <param name="interestLoopbackEnabled"></param>
		public void setInterestLoopbackEnabled(bool interestLoopbackEnabled) {
			node_.setInterestLoopbackEnabled(interestLoopbackEnabled);
		}
	
		/// <summary>
		/// Send the Interest through the transport, read the entire response and call
		/// onData, onTimeout or onNetworkNack as described below.
		/// </summary>
		///
		/// <param name="interest">The Interest to send.  This copies the Interest.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onNetworkNack">onNetworkNack.onNetworkNack(interest, networkNack) and does not call onTimeout. However, if a network Nack is received and onNetworkNack is null, do nothing and wait for the interest to time out. (Therefore, an application which does not yet process a network Nack reason treats a Nack the same as a timeout.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public virtual long expressInterest(Interest interest, OnData onData,
				OnTimeout onTimeout, OnNetworkNack onNetworkNack,
				WireFormat wireFormat) {
			long pendingInterestId = node_.getNextEntryId();
	
			// This copies the interest as required by Node.expressInterest.
			node_.expressInterest(pendingInterestId, interest, onData, onTimeout,
					onNetworkNack, wireFormat, this);
	
			return pendingInterestId;
		}
	
		/// <summary>
		/// Send the Interest through the transport, read the entire response and call
		/// onData, onTimeout or onNetworkNack as described below.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="interest">The Interest to send.  This copies the Interest.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onNetworkNack">onNetworkNack.onNetworkNack(interest, networkNack) and does not call onTimeout. However, if a network Nack is received and onNetworkNack is null, do nothing and wait for the interest to time out. (Therefore, an application which does not yet process a network Nack reason treats a Nack the same as a timeout.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Interest interest, OnData onData,
				OnTimeout onTimeout, OnNetworkNack onNetworkNack) {
			return expressInterest(interest, onData, onTimeout, onNetworkNack,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Send the Interest through the transport, read the entire response and call
		/// onData or onTimeout as described below.
		/// </summary>
		///
		/// <param name="interest">The Interest to send.  This copies the Interest.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Interest interest, OnData onData,
				OnTimeout onTimeout, WireFormat wireFormat) {
			return expressInterest(interest, onData, onTimeout, null, wireFormat);
		}
	
		/// <summary>
		/// Send the Interest through the transport, read the entire response and call
		/// onData or onTimeout as described below.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="interest">The Interest to send.  This copies the Interest.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Interest interest, OnData onData,
				OnTimeout onTimeout) {
			return expressInterest(interest, onData, onTimeout,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Send the Interest through the transport, read the entire response and call
		/// onData as described below.
		/// Ignore if the interest times out.
		/// </summary>
		///
		/// <param name="interest">The Interest to send.  This copies the Interest.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Interest interest, OnData onData,
				WireFormat wireFormat) {
			return expressInterest(interest, onData, null, wireFormat);
		}
	
		/// <summary>
		/// Send the Interest through the transport, read the entire response and call
		/// onData as described below.
		/// Ignore if the interest times out.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="interest">The Interest to send.  This copies the Interest.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Interest interest, OnData onData) {
			return expressInterest(interest, onData, null,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Encode name as an Interest. If interestTemplate is not null, use its
		/// interest selectors.
		/// Send the Interest through the transport, read the entire response and call
		/// onData, onTimeout or onNetworkNack as described below.
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="interestTemplate"></param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onNetworkNack">onNetworkNack.onNetworkNack(interest, networkNack) and does not call onTimeout. However, if a network Nack is received and onNetworkNack is null, do nothing and wait for the interest to time out. (Therefore, an application which does not yet process a network Nack reason treats a Nack the same as a timeout.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, Interest interestTemplate,
				OnData onData, OnTimeout onTimeout, OnNetworkNack onNetworkNack,
				WireFormat wireFormat) {
			long pendingInterestId = node_.getNextEntryId();
	
			// This copies the name object as required by Node.expressInterest.
			node_.expressInterest(pendingInterestId,
					getInterestCopy(name, interestTemplate), onData, onTimeout,
					onNetworkNack, wireFormat, this);
	
			return pendingInterestId;
		}
	
		/// <summary>
		/// Encode name as an Interest. If interestTemplate is not null, use its
		/// interest selectors.
		/// Send the Interest through the transport, read the entire response and call
		/// onData, onTimeout or onNetworkNack as described below.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="interestTemplate"></param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onNetworkNack">onNetworkNack.onNetworkNack(interest, networkNack) and does not call onTimeout. However, if a network Nack is received and onNetworkNack is null, do nothing and wait for the interest to time out. (Therefore, an application which does not yet process a network Nack reason treats a Nack the same as a timeout.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, Interest interestTemplate,
				OnData onData, OnTimeout onTimeout, OnNetworkNack onNetworkNack) {
			return expressInterest(name, interestTemplate, onData, onTimeout,
					onNetworkNack, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Encode name as an Interest, using a default interest lifetime.
		/// Send the Interest through the transport, read the entire response and call
		/// onData, onTimeout or onNetworkNack as described below.
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onNetworkNack">onNetworkNack.onNetworkNack(interest, networkNack) and does not call onTimeout. However, if a network Nack is received and onNetworkNack is null, do nothing and wait for the interest to time out. (Therefore, an application which does not yet process a network Nack reason treats a Nack the same as a timeout.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, OnData onData, OnTimeout onTimeout,
				OnNetworkNack onNetworkNack, WireFormat wireFormat) {
			return expressInterest(name, null, onData, onTimeout, onNetworkNack,
					wireFormat);
		}
	
		/// <summary>
		/// Encode name as an Interest, using a default interest lifetime.
		/// Send the Interest through the transport, read the entire response and call
		/// onData, onTimeout or onNetworkNack as described below.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onNetworkNack">onNetworkNack.onNetworkNack(interest, networkNack) and does not call onTimeout. However, if a network Nack is received and onNetworkNack is null, do nothing and wait for the interest to time out. (Therefore, an application which does not yet process a network Nack reason treats a Nack the same as a timeout.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, OnData onData, OnTimeout onTimeout,
				OnNetworkNack onNetworkNack) {
			return expressInterest(name, null, onData, onTimeout, onNetworkNack,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Encode name as an Interest. If interestTemplate is not null, use its
		/// interest selectors.
		/// Send the Interest through the transport, read the entire response and call
		/// onData or onTimeout as described below.
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="interestTemplate"></param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, Interest interestTemplate,
				OnData onData, OnTimeout onTimeout, WireFormat wireFormat) {
			return expressInterest(name, interestTemplate, onData, onTimeout, null,
					wireFormat);
		}
	
		/// <summary>
		/// Encode name as an Interest, using a default interest lifetime.
		/// Send the Interest through the transport, read the entire response and call
		/// onData or onTimeout as described below.
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, OnData onData, OnTimeout onTimeout,
				WireFormat wireFormat) {
			return expressInterest(name, null, onData, onTimeout, wireFormat);
		}
	
		/// <summary>
		/// Encode name as an Interest. If interestTemplate is not null, use its
		/// interest selectors.
		/// Send the Interest through the transport, read the entire response and call
		/// onData as described below.
		/// Ignore if the interest times out.
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="interestTemplate"></param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, Interest interestTemplate,
				OnData onData, WireFormat wireFormat) {
			return expressInterest(name, interestTemplate, onData, null, wireFormat);
		}
	
		/// <summary>
		/// Encode name as an Interest. If interestTemplate is not null, use its
		/// interest selectors.
		/// Send the Interest through the transport, read the entire response and call
		/// onData or onTimeout as described below.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="interestTemplate"></param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, Interest interestTemplate,
				OnData onData, OnTimeout onTimeout) {
			return expressInterest(name, interestTemplate, onData, onTimeout,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Encode name as an Interest. If interestTemplate is not null, use its
		/// interest selectors.
		/// Send the Interest through the transport, read the entire response and call
		/// onData as described below.
		/// Ignore if the interest times out.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="interestTemplate"></param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, Interest interestTemplate,
				OnData onData) {
			return expressInterest(name, interestTemplate, onData, null,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Encode name as an Interest, using a default interest lifetime.
		/// Send the Interest through the transport, read the entire response and call
		/// onData or onTimeout as described below.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onTimeout">interest given to expressInterest. If onTimeout is null, this does not use it. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, OnData onData, OnTimeout onTimeout) {
			return expressInterest(name, null, onData, onTimeout,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Encode name as an Interest, using a default interest lifetime.
		/// Send the Interest through the transport, read the entire response and call
		/// onData as described below.
		/// Ignore if the interest times out.
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, OnData onData, WireFormat wireFormat) {
			return expressInterest(name, null, onData, null, wireFormat);
		}
	
		/// <summary>
		/// Encode name as an Interest, using a default interest lifetime.
		/// Send the Interest through the transport, read the entire response and call
		/// onData as described below.
		/// Ignore if the interest times out.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="name">A Name for the interest. This copies the Name.</param>
		/// <param name="onData">expressInterest and data is the received Data object. NOTE: You must not change the interest object - if you need to change it then make a copy. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The pending interest ID which can be used with
		/// removePendingInterest.</returns>
		/// <exception cref="IOException">For I/O error in sending the interest.</exception>
		/// <exception cref="System.Exception">If the encoded interest size exceeds getMaxNdnPacketSize().</exception>
		public long expressInterest(Name name, OnData onData) {
			return expressInterest(name, null, onData, null,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Remove the pending interest entry with the pendingInterestId from the
		/// pending interest table. This does not affect another pending interest with
		/// a different pendingInterestId, even if it has the same interest name.
		/// If there is no entry with the pendingInterestId, do nothing.
		/// </summary>
		///
		/// <param name="pendingInterestId">The ID returned from expressInterest.</param>
		public void removePendingInterest(long pendingInterestId) {
			node_.removePendingInterest(pendingInterestId);
		}
	
		/// <summary>
		/// Set the KeyChain and certificate name used to sign command interests
		/// (e.g. for registerPrefix).
		/// </summary>
		///
		/// <param name="keyChain">object and pass it in. You can create a default KeyChain for your system with the default KeyChain constructor.</param>
		/// <param name="certificateName">with keyChain.getDefaultCertificateName() .</param>
		public void setCommandSigningInfo(KeyChain keyChain, Name certificateName) {
			commandKeyChain_ = keyChain;
			commandCertificateName_ = new Name(certificateName);
		}
	
		/// <summary>
		/// Set the certificate name used to sign command interest (e.g. for
		/// registerPrefix), using the KeyChain that was set with setCommandSigningInfo.
		/// </summary>
		///
		/// <param name="certificateName"></param>
		public void setCommandCertificateName(Name certificateName) {
			commandCertificateName_ = new Name(certificateName);
		}
	
		/// <summary>
		/// Append a timestamp component and a random value component to interest's
		/// name. Then use the keyChain and certificateName from setCommandSigningInfo
		/// to sign the interest. If the interest lifetime is not set, this sets it.
		/// </summary>
		///
		/// <param name="interest">The interest whose name is appended with components.</param>
		/// <param name="wireFormat"></param>
		/// <exception cref="System.Security.SecurityException">If cannot find the private key for thecertificateName.</exception>
		/// @note This method is an experimental feature. See the API docs for more detail at
		/// http://named-data.net/doc/ndn-ccl-api/face.html#face-makecommandinterest-method .
		public void makeCommandInterest(Interest interest, WireFormat wireFormat) {
			node_.makeCommandInterest(interest, commandKeyChain_,
					commandCertificateName_, wireFormat);
		}
	
		/// <summary>
		/// Append a timestamp component and a random value component to interest's
		/// name. Then use the keyChain and certificateName from setCommandSigningInfo
		/// to sign the interest. If the interest lifetime is not set, this sets it.
		/// Use the default WireFormat to encode the SignatureInfo and to encode the
		/// interest name for signing.
		/// </summary>
		///
		/// <param name="interest">The interest whose name is appended with components.</param>
		/// <exception cref="System.Security.SecurityException">If cannot find the private key for thecertificateName.</exception>
		/// @note This method is an experimental feature. See the API docs for more detail at
		/// http://named-data.net/doc/ndn-ccl-api/face.html#face-makecommandinterest-method .
		public void makeCommandInterest(Interest interest) {
			makeCommandInterest(interest, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Register prefix with the connected NDN hub and call onInterest when a
		/// matching interest is received. To register a prefix with NFD, you must
		/// first call setCommandSigningInfo.
		/// </summary>
		///
		/// <param name="prefix">A Name for the prefix to register. This copies the Name.</param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). The onInterest callback should supply the Data with face.putData(). NOTE: You must not change the prefix or filter objects - if you need to change them then make a copy. If onInterest is null, it is ignored and you must call setInterestFilter. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterSuccess">receives a success message from the forwarder. If onRegisterSuccess is null, this does not use it. (The onRegisterSuccess parameter comes after onRegisterFailed because it can be null or omitted, unlike onRegisterFailed.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="registrationOptions"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The registered prefix ID which can be used with
		/// removeRegisteredPrefix.</returns>
		/// <exception cref="IOException">For I/O error in sending the registration request.</exception>
		/// <exception cref="System.Security.SecurityException">If signing a command interest for NFD and cannotfind the private key for the certificateName.</exception>
		public virtual long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterFailed onRegisterFailed,
				OnRegisterSuccess onRegisterSuccess,
				RegistrationOptions registrationOptions, WireFormat wireFormat) {
			// Get the registeredPrefixId now so we can return it to the caller.
			long registeredPrefixId = node_.getNextEntryId();
	
			node_.registerPrefix(registeredPrefixId, prefix, onInterest,
					onRegisterFailed, onRegisterSuccess, registrationOptions,
					wireFormat, commandKeyChain_, commandCertificateName_, this);
	
			return registeredPrefixId;
		}
	
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterSuccess onRegisterSuccess,
				OnRegisterFailed onRegisterFailed,
				RegistrationOptions registrationOptions, WireFormat wireFormat) {
			return registerPrefix(prefix, onInterest, onRegisterFailed,
					onRegisterSuccess, registrationOptions, wireFormat);
		}
	
		/// <summary>
		/// Register prefix with the connected NDN hub and call onInterest when a
		/// matching interest is received.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="prefix">A Name for the prefix to register. This copies the Name.</param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). The onInterest callback should supply the Data with face.putData(). NOTE: You must not change the prefix or filter objects - if you need to change them then make a copy. If onInterest is null, it is ignored and you must call setInterestFilter. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterSuccess">receives a success message from the forwarder. If onRegisterSuccess is null, this does not use it. (The onRegisterSuccess parameter comes after onRegisterFailed because it can be null or omitted, unlike onRegisterFailed.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="registrationOptions"></param>
		/// <returns>The registered prefix ID which can be used with
		/// removeRegisteredPrefix.</returns>
		/// <exception cref="IOException">For I/O error in sending the registration request.</exception>
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterFailed onRegisterFailed,
				OnRegisterSuccess onRegisterSuccess,
				RegistrationOptions registrationOptions) {
			return registerPrefix(prefix, onInterest, onRegisterFailed,
					onRegisterSuccess, registrationOptions,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterSuccess onRegisterSuccess,
				OnRegisterFailed onRegisterFailed,
				RegistrationOptions registrationOptions) {
			return registerPrefix(prefix, onInterest, onRegisterFailed,
					onRegisterSuccess, registrationOptions,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Register prefix with the connected NDN hub and call onInterest when a
		/// matching interest is received.
		/// Use default RegistrationOptions.
		/// </summary>
		///
		/// <param name="prefix">A Name for the prefix to register. This copies the Name.</param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). The onInterest callback should supply the Data with face.putData(). NOTE: You must not change the prefix or filter objects - if you need to change them then make a copy. If onInterest is null, it is ignored and you must call setInterestFilter. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterSuccess">receives a success message from the forwarder. If onRegisterSuccess is null, this does not use it. (The onRegisterSuccess parameter comes after onRegisterFailed because it can be null or omitted, unlike onRegisterFailed.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The registered prefix ID which can be used with
		/// removeRegisteredPrefix.</returns>
		/// <exception cref="IOException">For I/O error in sending the registration request.</exception>
		/// <exception cref="System.Security.SecurityException">If signing a command interest for NFD and cannotfind the private key for the certificateName.</exception>
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterFailed onRegisterFailed,
				OnRegisterSuccess onRegisterSuccess, WireFormat wireFormat) {
			return registerPrefix(prefix, onInterest, onRegisterFailed,
					onRegisterSuccess, new RegistrationOptions(), wireFormat);
		}
	
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterSuccess onRegisterSuccess,
				OnRegisterFailed onRegisterFailed, WireFormat wireFormat) {
			return registerPrefix(prefix, onInterest, onRegisterFailed,
					onRegisterSuccess, new RegistrationOptions(), wireFormat);
		}
	
		/// <summary>
		/// Register prefix with the connected NDN hub and call onInterest when a
		/// matching interest is received.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// Use default RegistrationOptions.
		/// </summary>
		///
		/// <param name="prefix">A Name for the prefix to register. This copies the Name.</param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). The onInterest callback should supply the Data with face.putData(). NOTE: You must not change the prefix or filter objects - if you need to change them then make a copy. If onInterest is null, it is ignored and you must call setInterestFilter. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterSuccess">receives a success message from the forwarder. If onRegisterSuccess is null, this does not use it. (The onRegisterSuccess parameter comes after onRegisterFailed because it can be null or omitted, unlike onRegisterFailed.) NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The registered prefix ID which can be used with
		/// removeRegisteredPrefix.</returns>
		/// <exception cref="IOException">For I/O error in sending the registration request.</exception>
		/// <exception cref="System.Security.SecurityException">If signing a command interest for NFD and cannotfind the private key for the certificateName.</exception>
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterFailed onRegisterFailed,
				OnRegisterSuccess onRegisterSuccess) {
			return registerPrefix(prefix, onInterest, onRegisterFailed,
					onRegisterSuccess, new RegistrationOptions(),
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterSuccess onRegisterSuccess,
				OnRegisterFailed onRegisterFailed) {
			return registerPrefix(prefix, onInterest, onRegisterFailed,
					onRegisterSuccess, new RegistrationOptions(),
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Register prefix with the connected NDN hub and call onInterest when a
		/// matching interest is received. To register a prefix with NFD, you must
		/// first call setCommandSigningInfo.
		/// </summary>
		///
		/// <param name="prefix">A Name for the prefix to register. This copies the Name.</param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). The onInterest callback should supply the Data with face.putData(). NOTE: You must not change the prefix or filter objects - if you need to change them then make a copy. If onInterest is null, it is ignored and you must call setInterestFilter. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="registrationOptions"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The registered prefix ID which can be used with
		/// removeRegisteredPrefix.</returns>
		/// <exception cref="IOException">For I/O error in sending the registration request.</exception>
		/// <exception cref="System.Security.SecurityException">If signing a command interest for NFD and cannotfind the private key for the certificateName.</exception>
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterFailed onRegisterFailed,
				RegistrationOptions registrationOptions, WireFormat wireFormat) {
			return registerPrefix(prefix, onInterest, onRegisterFailed, null,
					registrationOptions, wireFormat);
		}
	
		/// <summary>
		/// Register prefix with the connected NDN hub and call onInterest when a
		/// matching interest is received. To register a prefix with NFD, you must
		/// first call setCommandSigningInfo.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// <param name="prefix">A Name for the prefix to register. This copies the Name.</param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). The onInterest callback should supply the Data with face.putData(). NOTE: You must not change the prefix or filter objects - if you need to change them then make a copy. If onInterest is null, it is ignored and you must call setInterestFilter. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="registrationOptions"></param>
		/// <returns>The registered prefix ID which can be used with
		/// removeRegisteredPrefix.</returns>
		/// <exception cref="IOException">For I/O error in sending the registration request.</exception>
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterFailed onRegisterFailed,
				RegistrationOptions registrationOptions) {
			return registerPrefix(prefix, onInterest, onRegisterFailed, null,
					registrationOptions, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Register prefix with the connected NDN hub and call onInterest when a
		/// matching interest is received. To register a prefix with NFD, you must
		/// first call setCommandSigningInfo.
		/// Use default RegistrationOptions.
		/// </summary>
		///
		/// <param name="prefix">A Name for the prefix to register. This copies the Name.</param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). The onInterest callback should supply the Data with face.putData(). NOTE: You must not change the prefix or filter objects - if you need to change them then make a copy. If onInterest is null, it is ignored and you must call setInterestFilter. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the message.</param>
		/// <returns>The registered prefix ID which can be used with
		/// removeRegisteredPrefix.</returns>
		/// <exception cref="IOException">For I/O error in sending the registration request.</exception>
		/// <exception cref="System.Security.SecurityException">If signing a command interest for NFD and cannotfind the private key for the certificateName.</exception>
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterFailed onRegisterFailed, WireFormat wireFormat) {
			return registerPrefix(prefix, onInterest, onRegisterFailed, null,
					new RegistrationOptions(), wireFormat);
		}
	
		/// <summary>
		/// Register prefix with the connected NDN hub and call onInterest when a
		/// matching interest is received. To register a prefix with NFD, you must
		/// first call setCommandSigningInfo.
		/// This uses the default WireFormat.getDefaultWireFormat().
		/// Use default RegistrationOptions.
		/// </summary>
		///
		/// <param name="prefix">A Name for the prefix to register. This copies the Name.</param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). The onInterest callback should supply the Data with face.putData(). NOTE: You must not change the prefix or filter objects - if you need to change them then make a copy. If onInterest is null, it is ignored and you must call setInterestFilter. NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onRegisterFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The registered prefix ID which can be used with
		/// removeRegisteredPrefix.</returns>
		/// <exception cref="IOException">For I/O error in sending the registration request.</exception>
		/// <exception cref="System.Security.SecurityException">If signing a command interest for NFD and cannotfind the private key for the certificateName.</exception>
		public long registerPrefix(Name prefix, OnInterestCallback onInterest,
				OnRegisterFailed onRegisterFailed) {
			return registerPrefix(prefix, onInterest, onRegisterFailed, null,
					new RegistrationOptions(), net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Remove the registered prefix entry with the registeredPrefixId from the
		/// registered prefix table. This does not affect another registered prefix with
		/// a different registeredPrefixId, even if it has the same prefix name. If an
		/// interest filter was automatically created by registerPrefix, also remove it.
		/// If there is no entry with the registeredPrefixId, do nothing.
		/// </summary>
		///
		/// <param name="registeredPrefixId">The ID returned from registerPrefix.</param>
		public void removeRegisteredPrefix(long registeredPrefixId) {
			node_.removeRegisteredPrefix(registeredPrefixId);
		}
	
		/// <summary>
		/// Add an entry to the local interest filter table to call the onInterest
		/// callback for a matching incoming Interest. This method only modifies the
		/// library's local callback table and does not register the prefix with the
		/// forwarder. It will always succeed. To register a prefix with the forwarder,
		/// use registerPrefix.
		/// </summary>
		///
		/// <param name="filter"></param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The interest filter ID which can be used with unsetInterestFilter.</returns>
		public long setInterestFilter(InterestFilter filter,
				OnInterestCallback onInterest) {
			long interestFilterId = node_.getNextEntryId();
	
			node_.setInterestFilter(interestFilterId, filter, onInterest, this);
	
			return interestFilterId;
		}
	
		/// <summary>
		/// Add an entry to the local interest filter table to call the onInterest
		/// callback for a matching incoming Interest. This method only modifies the
		/// library's local callback table and does not register the prefix with the
		/// forwarder. It will always succeed. To register a prefix with the forwarder,
		/// use registerPrefix.
		/// </summary>
		///
		/// <param name="prefix"></param>
		/// <param name="onInterest">onInterest.onInterest(prefix, interest, face, interestFilterId, filter). NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <returns>The interest filter ID which can be used with unsetInterestFilter.</returns>
		public long setInterestFilter(Name prefix, OnInterestCallback onInterest) {
			return setInterestFilter(new InterestFilter(prefix), onInterest);
		}
	
		/// <summary>
		/// Remove the interest filter entry which has the interestFilterId from the
		/// interest filter table. This does not affect another interest filter with
		/// a different interestFilterId, even if it has the same prefix name.
		/// If there is no entry with the interestFilterId, do nothing.
		/// </summary>
		///
		/// <param name="interestFilterId">The ID returned from setInterestFilter.</param>
		public void unsetInterestFilter(long interestFilterId) {
			node_.unsetInterestFilter(interestFilterId);
		}
	
		/// <summary>
		/// The OnInterestCallback calls this to put a Data packet which satisfies an
		/// Interest.
		/// </summary>
		///
		/// <param name="data">The Data packet which satisfies the interest.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the Data packet.</param>
		/// <exception cref="System.Exception">If the encoded Data packet size exceeds getMaxNdnPacketSize().</exception>
		public virtual void putData(Data data, WireFormat wireFormat) {
			node_.putData(data, wireFormat);
		}
	
		/// <summary>
		/// The OnInterestCallback calls this to put a Data packet which satisfies an
		/// Interest.
		/// This uses the default WireFormat.getDefaultWireFormat() to encode data.
		/// </summary>
		///
		/// <param name="data">The Data packet which satisfies the interest.</param>
		/// <exception cref="System.Exception">If the encoded Data packet size exceeds getMaxNdnPacketSize().</exception>
		public void putData(Data data) {
			putData(data, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Send the encoded packet out through the face.
		/// </summary>
		///
		/// <param name="encoding">The blob with the the encoded packet to send.</param>
		/// <exception cref="System.Exception">If the encoded packet size exceeds getMaxNdnPacketSize().</exception>
		public void send(Blob encoding) {
			send(encoding.buf());
		}
	
		/// <summary>
		/// Send the encoded packet out through the face.
		/// </summary>
		///
		/// <param name="encoding"></param>
		/// <exception cref="System.Exception">If the encoded packet size exceeds getMaxNdnPacketSize().</exception>
		public void send(ByteBuffer encoding) {
			node_.send(encoding);
		}
	
		/// <summary>
		/// The OnInterest callback can call this to put a Nack for the received Interest.
		/// </summary>
		///
		/// @note This method is an experimental feature, and the API may change.
		/// <param name="interest">The Interest to put in the Nack packet.</param>
		/// <param name="networkNack"></param>
		/// <exception cref="System.Exception">If the encoded Nack packet size exceeds getMaxNdnPacketSize().</exception>
		public void putNack(Interest interest, NetworkNack networkNack) {
			node_.putNack(interest, networkNack);
		}
	
		/// <summary>
		/// Process any packets to receive and call callbacks such as onData,
		/// onInterest or onTimeout. This returns immediately if there is no data to
		/// receive. This blocks while calling the callbacks. You should repeatedly
		/// call this from an event loop, with calls to sleep as needed so that the
		/// loop doesn’t use 100% of the CPU. Since processEvents modifies the pending
		/// interest table, your application should make sure that it calls
		/// processEvents in the same thread as expressInterest (which also modifies
		/// the pending interest table).
		/// This may throw an exception for reading data or in the callback for
		/// processing the data. If you call this from an main event loop, you may want
		/// to catch and log/disregard all exceptions.
		/// </summary>
		///
		public virtual void processEvents() {
			// Just call Node's processEvents.
			node_.processEvents();
		}
	
		/// <summary>
		/// Check if the face is local based on the current connection through the
		/// Transport; some Transport may cause network IO (e.g. an IP host name lookup).
		/// </summary>
		///
		/// <returns>True if the face is local, false if not.</returns>
		/// <exception cref="IOException"></exception>
		/// @note This is an experimental feature. This API may change in the future.
		public bool isLocal() {
			return node_.isLocal();
		}
	
		/// <summary>
		/// Shut down and disconnect this Face.
		/// </summary>
		///
		public void shutdown() {
			node_.shutdown();
		}
	
		/// <summary>
		/// Get the practical limit of the size of a network-layer packet. If a packet
		/// is larger than this, the library or application MAY drop it.
		/// </summary>
		///
		/// <returns>The maximum NDN packet size.</returns>
		public static int getMaxNdnPacketSize() {
			return net.named_data.jndn.util.Common.MAX_NDN_PACKET_SIZE;
		}
	
		/// <summary>
		/// Call callback.run() after the given delay. Even though this is public,
		/// it is not part of the public API of Face. This default implementation just
		/// calls Node.callLater, but a subclass can override.
		/// </summary>
		///
		/// <param name="delayMilliseconds">The delay in milliseconds.</param>
		/// <param name="callback">This calls callback.run() after the delay.</param>
		public virtual void callLater(double delayMilliseconds, IRunnable callback) {
			node_.callLater(delayMilliseconds, callback);
		}
	
		/// <summary>
		/// Do the work of expressInterest to make an Interest based on name and
		/// interestTemplate.
		/// </summary>
		///
		/// <param name="name">A Name for the interest.  This copies the Name.</param>
		/// <param name="interestTemplate"></param>
		/// <returns>The Interest, suitable for Node.expressInterest.</returns>
		static protected internal Interest getInterestCopy(Name name,
				Interest interestTemplate) {
			if (interestTemplate != null) {
				// Copy the interestTemplate.
				Interest interestCopy = new Interest(interestTemplate);
				interestCopy.setName(name);
				return interestCopy;
			} else {
				Interest interestCopy_0 = new Interest(name);
				interestCopy_0.setInterestLifetimeMilliseconds(4000.0d);
				return interestCopy_0;
			}
		}
	
		protected internal readonly Node node_;
		protected internal KeyChain commandKeyChain_;
		protected internal Name commandCertificateName_;
	}
}
