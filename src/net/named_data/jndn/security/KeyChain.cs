// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2014-2017 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.security {
	
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.spec;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.encoding.der;
	using net.named_data.jndn.security.certificate;
	using net.named_data.jndn.security.identity;
	using net.named_data.jndn.security.pib;
	using net.named_data.jndn.security.policy;
	using net.named_data.jndn.security.tpm;
	using net.named_data.jndn.security.v2;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// KeyChain is the main class of the security library.
	/// The KeyChain class provides a set of interfaces to the security library such
	/// as identity management, policy configuration and packet signing and
	/// verification.
	/// </summary>
	///
	/// @note This class is an experimental feature.  See the API docs for more
	/// detail at
	/// http://named-data.net/doc/ndn-ccl-api/key-chain.html .
	public class KeyChain {
		public sealed class Anonymous_C5 : OnDataValidationFailed {
			private readonly OnVerifyFailed onVerifyFailed;
	
			public Anonymous_C5(OnVerifyFailed onVerifyFailed_0) {
				this.onVerifyFailed = onVerifyFailed_0;
			}
	
			public void onDataValidationFailed(Data localData, String reason) {
				onVerifyFailed.onVerifyFailed(localData);
			}
		}
	
		public sealed class Anonymous_C4 : OnInterestValidationFailed {
			private readonly OnVerifyInterestFailed onVerifyFailed;
	
			public Anonymous_C4(OnVerifyInterestFailed onVerifyFailed_0) {
				this.onVerifyFailed = onVerifyFailed_0;
			}
	
			public void onInterestValidationFailed(Interest localInterest,
					String reason) {
				onVerifyFailed.onVerifyInterestFailed(localInterest);
			}
		}
	
		public sealed class Anonymous_C3 : KeyChain.MakePibImpl  {
			public PibImpl makePibImpl(String location) {
				return new PibSqlite3(location);
			}
		}
	
		public sealed class Anonymous_C2 : KeyChain.MakePibImpl  {
			public PibImpl makePibImpl(String location) {
				return new PibMemory();
			}
		}
	
		public sealed class Anonymous_C1 : KeyChain.MakeTpmBackEnd  {
			public TpmBackEnd makeTpmBackEnd(String location) {
				return new TpmBackEndFile(location);
			}
		}
	
		public sealed class Anonymous_C0 : KeyChain.MakeTpmBackEnd  {
			public TpmBackEnd makeTpmBackEnd(String location) {
				return new TpmBackEndMemory();
			}
		}
	
		/// <summary>
		/// A KeyChain.Error extends Exception and represents an error in KeyChain
		/// processing.
		/// Note that even though this is called "Error" to be consistent with the
		/// other libraries, it extends the Java Exception class, not Error.
		/// </summary>
		///
		[Serializable]
		public class Error : Exception {
			public Error(String message) : base(message) {
			}
		}
	
		/// <summary>
		/// A KeyChain.InvalidSigningInfoError extends KeyChain.Error to indicate
		/// that the supplied SigningInfo is invalid.
		/// </summary>
		///
		[Serializable]
		public class InvalidSigningInfoError : KeyChain.Error {
			public InvalidSigningInfoError(String message) : base(message) {
			}
		}
	
		/// <summary>
		/// A KeyChain.LocatorMismatchError extends KeyChain.Error to indicate that
		/// the supplied TPM locator does not match the locator stored in the PIB.
		/// </summary>
		///
		[Serializable]
		public class LocatorMismatchError : KeyChain.Error {
			public LocatorMismatchError(String message) : base(message) {
			}
		}
	
		public interface MakePibImpl {
			PibImpl makePibImpl(String location);
		}
	
		public interface MakeTpmBackEnd {
			TpmBackEnd makeTpmBackEnd(String location);
		}
	
		/// <summary>
		/// Create a KeyChain to use the PIB and TPM defined by the given locators.
		/// This creates a security v2 KeyChain that uses CertificateV2, Pib, Tpm and
		/// Validator (instead of v1 Certificate, IdentityStorage, PrivateKeyStorage
		/// and PolicyManager).
		/// </summary>
		///
		/// <param name="pibLocator">The PIB locator, e.g., "pib-sqlite3:/example/dir".</param>
		/// <param name="tpmLocator">The TPM locator, e.g., "tpm-memory:".</param>
		/// <param name="allowReset"></param>
		/// <exception cref="KeyChain.LocatorMismatchError">if the supplied TPM locator does notmatch the locator stored in the PIB.</exception>
		public KeyChain(String pibLocator, String tpmLocator, bool allowReset) {
			this.face_ = null;
			isSecurityV1_ = false;
			construct(pibLocator, tpmLocator, allowReset);
		}
	
		/// <summary>
		/// Create a KeyChain to use the PIB and TPM defined by the given locators.
		/// Don't allow resetting the PIB when the supplied tpmLocator mismatches the
		/// one in the PIB.
		/// This creates a security v2 KeyChain that uses CertificateV2, Pib, Tpm and
		/// Validator (instead of v1 Certificate, IdentityStorage, PrivateKeyStorage
		/// and PolicyManager).
		/// </summary>
		///
		/// <param name="pibLocator">The PIB locator, e.g., "pib-sqlite3:/example/dir".</param>
		/// <param name="tpmLocator">The TPM locator, e.g., "tpm-memory:".</param>
		/// <exception cref="KeyChain.LocatorMismatchError">if the supplied TPM locator does notmatch the locator stored in the PIB.</exception>
		public KeyChain(String pibLocator, String tpmLocator) {
			this.face_ = null;
			isSecurityV1_ = false;
			construct(pibLocator, tpmLocator, false);
		}
	
		/// <summary>
		/// This is a temporary constructor for the transition to security v2. This
		/// creates a security v2 KeyChain but still uses the v1 PolicyManager.
		/// </summary>
		///
		public KeyChain(PibImpl pibImpl, TpmBackEnd tpmBackEnd,
				PolicyManager policyManager) {
			this.face_ = null;
			isSecurityV1_ = false;
			policyManager_ = policyManager;
	
			pib_ = new Pib("", "", pibImpl);
			tpm_ = new Tpm("", "", tpmBackEnd);
		}
	
		/// <summary>
		/// Create a new security v1 KeyChain with the given IdentityManager and
		/// PolicyManager. For security v2, use KeyChain(pibLocator, tpmLocator) or the
		/// default constructor if your .ndn folder is already initialized for v2.
		/// </summary>
		///
		/// <param name="identityManager">An object of a subclass of IdentityManager.</param>
		/// <param name="policyManager">An object of a subclass of PolicyManager.</param>
		public KeyChain(IdentityManager identityManager, PolicyManager policyManager) {
			this.face_ = null;
			isSecurityV1_ = true;
	
			identityManager_ = identityManager;
			policyManager_ = policyManager;
		}
	
		/// <summary>
		/// Create a new security v1 KeyChain with the given IdentityManager and a
		/// NoVerifyPolicyManager. For security v2, use KeyChain(pibLocator, tpmLocator)
		/// or the default constructor if your .ndn folder is already initialized for v2.
		/// </summary>
		///
		/// <param name="identityManager">An object of a subclass of IdentityManager.</param>
		public KeyChain(IdentityManager identityManager) {
			this.face_ = null;
			isSecurityV1_ = true;
	
			identityManager_ = identityManager;
			policyManager_ = new NoVerifyPolicyManager();
		}
	
		/// <summary>
		/// Create a KeyChain with the default PIB and TPM, which are
		/// platform-dependent and can be overridden system-wide or individually by the
		/// user. This creates a security v2 KeyChain that uses CertificateV2, Pib, Tpm
		/// and Validator. However, if the default security v1 database file still
		/// exists, and the default security v2 database file does not yet exists,then
		/// assume that the system is running an older NFD and create a security v1
		/// KeyChain with the default IdentityManager and a NoVerifyPolicyManager.
		/// Note: To create a security v2 KeyChain on android, you must use the
		/// KeyChain constructor to provide AndroidSqlite3Pib and TpmBackEndFile
		/// objects which are initialized with the explicit directory for the Android
		/// filesDir.
		/// </summary>
		///
		public KeyChain() {
			this.face_ = null;
			isSecurityV1_ = false;
	
			if (net.named_data.jndn.security.identity.BasicIdentityStorage.getDefaultDatabaseFilePath().Exists
					&& !net.named_data.jndn.security.pib.PibSqlite3.getDefaultDatabaseFilePath().Exists) {
				// The security v1 SQLite file still exists and the security v2 does not yet.
				isSecurityV1_ = true;
				identityManager_ = new IdentityManager();
				policyManager_ = new NoVerifyPolicyManager();
	
				return;
			}
	
			construct("", "", true);
		}
	
		public Pib getPib() {
			if (isSecurityV1_)
				throw new AssertionError("getPib is not supported for security v1");
	
			return pib_;
		}
	
		public Tpm getTpm() {
			if (isSecurityV1_)
				throw new AssertionError("getTpm is not supported for security v1");
	
			return tpm_;
		}
	
		// Identity management
	
		/// <summary>
		/// Create a security V2 identity for identityName. This method will check if
		/// the identity exists in PIB and whether the identity has a default key and
		/// default certificate. If the identity does not exist, this method will
		/// create the identity in PIB. If the identity's default key does not exist,
		/// this method will create a key pair and set it as the identity's default
		/// key. If the key's default certificate is missing, this method will create a
		/// self-signed certificate for the key. If identityName did not exist and no
		/// default identity was selected before, the created identity will be set as
		/// the default identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="params"></param>
		/// <returns>The created PibIdentity instance.</returns>
		public PibIdentity createIdentityV2(Name identityName,
				KeyParams paras) {
			PibIdentity id = pib_.addIdentity_(identityName);
	
			PibKey key;
			try {
				key = id.getDefaultKey();
			} catch (Pib.Error ex) {
				key = createKey(id, paras);
			}
	
			try {
				key.getDefaultCertificate();
			} catch (Pib.Error ex_0) {
				ILOG.J2CsMapping.Util.Logging.Logger.getLogger(this.GetType().FullName).log(
						ILOG.J2CsMapping.Util.Logging.Level.INFO,
						"No default cert for " + key.getName()
								+ ", requesting self-signing");
				selfSign(key);
			}
	
			return id;
		}
	
		/// <summary>
		/// Create a security V2 identity for identityName. This method will check if
		/// the identity exists in PIB and whether the identity has a default key and
		/// default certificate. If the identity does not exist, this method will
		/// create the identity in PIB. If the identity's default key does not exist,
		/// this method will create a key pair using getDefaultKeyParams() and set it
		/// as the identity's default key. If the key's default certificate is missing,
		/// this method will create a self-signed certificate for the key. If
		/// identityName did not exist and no default identity was selected before, the
		/// created identity will be set as the default identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The created Identity instance.</returns>
		public PibIdentity createIdentityV2(Name identityName) {
			return createIdentityV2(identityName, getDefaultKeyParams());
		}
	
		/// <summary>
		/// Delete the identity. After this operation, the identity is invalid.
		/// </summary>
		///
		/// <param name="identity">The identity to delete.</param>
		public void deleteIdentity(PibIdentity identity) {
			Name identityName = identity.getName();
	
			ArrayList<Name> keyNames = identity.getKeys_().getKeyNames();
			/* foreach */
			foreach (Name keyName  in  keyNames)
				tpm_.deleteKey_(keyName);
	
			pib_.removeIdentity_(identityName);
			// TODO: Mark identity as invalid.
		}
	
		/// <summary>
		/// Set the identity as the default identity.
		/// </summary>
		///
		/// <param name="identity">The identity to make the default.</param>
		public void setDefaultIdentity(PibIdentity identity) {
			pib_.setDefaultIdentity_(identity.getName());
		}
	
		// Key management
	
		/// <summary>
		/// Create a key for the identity according to params. If the identity had no
		/// default key selected, the created key will be set as the default for this
		/// identity. This method will also create a self-signed certificate for the
		/// created key.
		/// </summary>
		///
		/// <param name="identity">A valid PibIdentity object.</param>
		/// <param name="params"></param>
		/// <returns>The new PibKey.</returns>
		public PibKey createKey(PibIdentity identity, KeyParams paras) {
			// Create the key in the TPM.
			Name keyName = tpm_.createKey_(identity.getName(), paras);
	
			// Set up the key info in the PIB.
			Blob publicKey = tpm_.getPublicKey(keyName);
			PibKey key = identity.addKey_(publicKey.buf(), keyName);
	
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger(this.GetType().FullName).log(
					ILOG.J2CsMapping.Util.Logging.Level.INFO,
					"Requesting self-signing for newly created key "
							+ key.getName().toUri());
			selfSign(key);
	
			return key;
		}
	
		/// <summary>
		/// Create a key for the identity according to getDefaultKeyParams(). If the
		/// identity had no default key selected, the created key will be set as the
		/// default for this identity. This method will also create a self-signed
		/// certificate for the created key.
		/// </summary>
		///
		/// <param name="identity">A valid PibIdentity object.</param>
		/// <returns>The new PibKey.</returns>
		public PibKey createKey(PibIdentity identity) {
			return createKey(identity, getDefaultKeyParams());
		}
	
		/// <summary>
		/// Delete the given key of the given identity. The key becomes invalid.
		/// </summary>
		///
		/// <param name="identity">A valid PibIdentity object.</param>
		/// <param name="key">The key to delete.</param>
		/// <exception cref="System.ArgumentException">If the key does not belong to the identity.</exception>
		public void deleteKey(PibIdentity identity, PibKey key) {
			Name keyName = key.getName();
			if (!identity.getName().equals(key.getIdentityName()))
				throw new ArgumentException("Identity `"
						+ identity.getName().toUri() + "` does not match key `"
						+ keyName.toUri() + "`");
	
			identity.removeKey_(keyName);
			tpm_.deleteKey_(keyName);
		}
	
		/// <summary>
		/// Set the key as the default key of identity.
		/// </summary>
		///
		/// <param name="identity">A valid PibIdentity object.</param>
		/// <param name="key">The key to become the default.</param>
		/// <exception cref="System.ArgumentException">If the key does not belong to the identity.</exception>
		public void setDefaultKey(PibIdentity identity, PibKey key) {
			if (!identity.getName().equals(key.getIdentityName()))
				throw new ArgumentException("Identity `"
						+ identity.getName().toUri() + "` does not match key `"
						+ key.getName().toUri() + "`");
	
			identity.setDefaultKey_(key.getName());
		}
	
		// Certificate management
	
		/// <summary>
		/// Add a certificate for the key. If the key had no default certificate
		/// selected, the added certificate will be set as the default certificate for
		/// this key.
		/// </summary>
		///
		/// <param name="key">A valid PibKey object.</param>
		/// <param name="certificate">The certificate to add. This copies the object.</param>
		/// @note This method overwrites a certificate with the same name, without
		/// considering the implicit digest.
		/// <exception cref="System.ArgumentException">If the key does not match the certificate.</exception>
		public void addCertificate(PibKey key, CertificateV2 certificate) {
			if (!key.getName().equals(certificate.getKeyName())
					|| !certificate.getContent().equals(key.getPublicKey()))
				throw new ArgumentException("Key `" + key.getName().toUri()
						+ "` does not match certificate `"
						+ certificate.getKeyName().toUri() + "`");
	
			key.addCertificate_(certificate);
		}
	
		/// <summary>
		/// Delete the certificate with the given name from the given key.
		/// If the certificate does not exist, this does nothing.
		/// </summary>
		///
		/// <param name="key">A valid PibKey object.</param>
		/// <param name="certificateName">The name of the certificate to delete.</param>
		/// <exception cref="System.ArgumentException">If certificateName does not followcertificate naming conventions.</exception>
		public void deleteCertificate(PibKey key, Name certificateName) {
			if (!net.named_data.jndn.security.v2.CertificateV2.isValidName(certificateName))
				throw new ArgumentException("Wrong certificate name `"
						+ certificateName.toUri() + "`");
	
			key.removeCertificate_(certificateName);
		}
	
		/// <summary>
		/// Set the certificate as the default certificate of the key. The certificate
		/// will be added to the key, potentially overriding an existing certificate if
		/// it has the same name (without considering implicit digest).
		/// </summary>
		///
		/// <param name="key">A valid PibKey object.</param>
		/// <param name="certificate"></param>
		public void setDefaultCertificate(PibKey key,
				CertificateV2 certificate) {
			// This replaces the certificate it it exists.
			addCertificate(key, certificate);
			key.setDefaultCertificate_(certificate.getName());
		}
	
		// Signing
	
		/// <summary>
		/// Wire encode the Data object, sign it according to the supplied signing
		/// parameters, and set its signature.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="params">The signing parameters.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		/// <exception cref="KeyChain.Error">if signing fails.</exception>
		/// <exception cref="KeyChain.InvalidSigningInfoError">if params is invalid, or if theidentity, key or certificate specified in params does not exist.</exception>
		public void sign(Data data, SigningInfo paras, WireFormat wireFormat) {
			Name[] keyName = new Name[1];
			Signature signatureInfo = prepareSignatureInfo(paras, keyName);
	
			data.setSignature(signatureInfo);
	
			// Encode once to get the signed portion.
			SignedBlob encoding = data.wireEncode(wireFormat);
	
			Blob signatureBytes = sign(encoding.signedBuf(), keyName[0],
					paras.getDigestAlgorithm());
			data.getSignature().setSignature(signatureBytes);
	
			// Encode again to include the signature.
			data.wireEncode(wireFormat);
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it according to the supplied signing
		/// parameters, and set its signature.
		/// Use the default WireFormat.getDefaultWireFormat()
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="params">The signing parameters.</param>
		/// <exception cref="KeyChain.Error">if signing fails.</exception>
		/// <exception cref="KeyChain.InvalidSigningInfoError">if params is invalid, or if theidentity, key or certificate specified in params does not exist.</exception>
		public void sign(Data data, SigningInfo paras) {
			sign(data, paras, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it with the default key of the default
		/// identity, and set its signature.
		/// If this is a security v1 KeyChain then use the IdentityManager to get the
		/// default identity. Otherwise use the PIB.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void sign(Data data, WireFormat wireFormat) {
			if (isSecurityV1_) {
				identityManager_.signByCertificate(data,
						prepareDefaultCertificateName(), wireFormat);
				return;
			}
	
			sign(data, defaultSigningInfo_, wireFormat);
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it with the default key of the default
		/// identity, and set its signature.
		/// If this is a security v1 KeyChain then use the IdentityManager to get the
		/// default identity. Otherwise use the PIB.
		/// Use the default WireFormat.getDefaultWireFormat()
		/// </summary>
		///
		/// <param name="data"></param>
		public void sign(Data data) {
			sign(data, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Sign the Interest according to the supplied signing parameters. Append a
		/// SignatureInfo to the Interest name, sign the encoded name components and
		/// append a final name component with the signature bits.
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="params">The signing parameters.</param>
		/// <param name="wireFormat"></param>
		/// <exception cref="KeyChain.Error">if signing fails.</exception>
		/// <exception cref="KeyChain.InvalidSigningInfoError">if params is invalid, or if theidentity, key or certificate specified in params does not exist.</exception>
		public void sign(Interest interest, SigningInfo paras,
				WireFormat wireFormat) {
			Name[] keyName = new Name[1];
			Signature signatureInfo = prepareSignatureInfo(paras, keyName);
	
			// Append the encoded SignatureInfo.
			interest.getName()
					.append(wireFormat.encodeSignatureInfo(signatureInfo));
	
			// Append an empty signature so that the "signedPortion" is correct.
			interest.getName().append(new Name.Component());
			// Encode once to get the signed portion, and sign.
			SignedBlob encoding = interest.wireEncode(wireFormat);
			Blob signatureBytes = sign(encoding.signedBuf(), keyName[0],
					paras.getDigestAlgorithm());
			signatureInfo.setSignature(signatureBytes);
	
			// Remove the empty signature and append the real one.
			interest.setName(interest.getName().getPrefix(-1)
					.append(wireFormat.encodeSignatureValue(signatureInfo)));
		}
	
		/// <summary>
		/// Sign the Interest according to the supplied signing parameters. Append a
		/// SignatureInfo to the Interest name, sign the encoded name components and
		/// append a final name component with the signature bits.
		/// Use the default WireFormat.getDefaultWireFormat()
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="params">The signing parameters.</param>
		/// <exception cref="KeyChain.Error">if signing fails.</exception>
		/// <exception cref="KeyChain.InvalidSigningInfoError">if params is invalid, or if theidentity, key or certificate specified in params does not exist.</exception>
		public void sign(Interest interest, SigningInfo paras) {
			sign(interest, paras, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Sign the Interest with the default key of the default identity. Append a
		/// SignatureInfo to the Interest name, sign the encoded name components and
		/// append a final name component with the signature bits.
		/// If this is a security v1 KeyChain then use the IdentityManager to get the
		/// default identity. Otherwise use the PIB.
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="wireFormat"></param>
		public void sign(Interest interest, WireFormat wireFormat) {
			if (isSecurityV1_) {
				identityManager_.signInterestByCertificate(interest,
						prepareDefaultCertificateName(), wireFormat);
				return;
			}
	
			sign(interest, defaultSigningInfo_, wireFormat);
		}
	
		/// <summary>
		/// Sign the Interest with the default key of the default identity. Append a
		/// SignatureInfo to the Interest name, sign the encoded name components and
		/// append a final name component with the signature bits.
		/// Use the default WireFormat.getDefaultWireFormat()
		/// If this is a security v1 KeyChain then use the IdentityManager to get the
		/// default identity. Otherwise use the PIB.
		/// </summary>
		///
		/// <param name="interest"></param>
		public void sign(Interest interest) {
			sign(interest, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Sign the byte buffer according to the supplied signing parameters.
		/// </summary>
		///
		/// <param name="buffer">The byte buffer to be signed.</param>
		/// <param name="params">certificate, this selects the corresponding key.</param>
		/// <returns>The signature Blob, or an isNull Blob if params.getDigestAlgorithm()
		/// is unrecognized.</returns>
		public Blob sign(ByteBuffer buffer, SigningInfo paras) {
			Name[] keyName = new Name[1];
			Signature signatureInfo = prepareSignatureInfo(paras, keyName);
	
			return sign(buffer, keyName[0], paras.getDigestAlgorithm());
		}
	
		/// <summary>
		/// Sign the byte buffer using the default key of the default identity.
		/// </summary>
		///
		/// <param name="buffer">The byte buffer to be signed.</param>
		/// <returns>The signature Blob.</returns>
		public Blob sign(ByteBuffer buffer) {
			return sign(buffer, defaultSigningInfo_);
		}
	
		/// <summary>
		/// Generate a self-signed certificate for the public key and add it to the
		/// PIB. This creates the certificate name from the key name by appending
		/// "self" and a version based on the current time. If no default certificate
		/// for the key has been set, then set the certificate as the default for the
		/// key.
		/// </summary>
		///
		/// <param name="key">The PibKey with the key name and public key.</param>
		/// <returns>The new certificate.</returns>
		public CertificateV2 selfSign(PibKey key) {
			CertificateV2 certificate = new CertificateV2();
	
			// Set the name.
			double now = net.named_data.jndn.util.Common.getNowMilliseconds();
			Name certificateName = new Name(key.getName());
			certificateName.append("self").appendVersion((long) now);
			certificate.setName(certificateName);
	
			// Set the MetaInfo.
			certificate.getMetaInfo().setType(net.named_data.jndn.ContentType.KEY);
			// Set a one-hour freshness period.
			certificate.getMetaInfo().setFreshnessPeriod(3600 * 1000.0d);
	
			// Set the content.
			certificate.setContent(key.getPublicKey());
	
			// Set the signature-info.
			SigningInfo signingInfo = new SigningInfo(key);
			Name[] dummyKeyName = new Name[1];
			certificate
					.setSignature(prepareSignatureInfo(signingInfo, dummyKeyName));
			// Set a 20-year validity period.
			net.named_data.jndn.security.ValidityPeriod.getFromSignature(certificate.getSignature()).setPeriod(
					now, now + 20 * 365 * 24 * 3600 * 1000.0d);
	
			sign(certificate, signingInfo);
	
			try {
				key.addCertificate_(certificate);
			} catch (CertificateV2.Error ex) {
				// We don't expect this since we just created the certificate.
				throw new KeyChain.Error ("Error encoding certificate: " + ex);
			}
			return certificate;
		}
	
		// Import and export
	
		/// <summary>
		/// Import a certificate and its corresponding private key encapsulated in a
		/// SafeBag. If the certificate and key are imported properly, the default
		/// setting will be updated as if a new key and certificate is added into this
		/// KeyChain.
		/// </summary>
		///
		/// <param name="safeBag"></param>
		/// <param name="password">If the password is null, import an unencrypted PKCS #8 PrivateKeyInfo.</param>
		/// <exception cref="KeyChain.Error">if the private key cannot be imported, or if apublic key or private key of the same name already exists, or if acertificate of the same name already exists.</exception>
		public void importSafeBag(SafeBag safeBag, ByteBuffer password) {
			CertificateV2 certificate = new CertificateV2(safeBag.getCertificate());
			Name identity = certificate.getIdentity();
			Name keyName = certificate.getKeyName();
			Blob publicKeyBits = certificate.getPublicKey();
	
			if (tpm_.hasKey(keyName))
				throw new KeyChain.Error("Private key `" + keyName.toUri()
						+ "` already exists");
	
			try {
				PibIdentity existingId = pib_.getIdentity(identity);
				existingId.getKey(keyName);
				throw new KeyChain.Error("Public key `" + keyName.toUri()
						+ "` already exists");
			} catch (Pib.Error ex) {
				// Either the identity or the key doesn't exist, so OK to import.
			}
	
			try {
				tpm_.importPrivateKey_(keyName, safeBag.getPrivateKeyBag().buf(),
						password);
			} catch (Exception ex_0) {
				throw new KeyChain.Error("Failed to import private key `"
						+ keyName.toUri() + "`");
			}
	
			// Check the consistency of the private key and certificate.
			Blob content = new Blob(new int[] { 0x01, 0x02, 0x03, 0x04 });
			Blob signatureBits;
			try {
				signatureBits = tpm_.sign(content.buf(), keyName,
						net.named_data.jndn.security.DigestAlgorithm.SHA256);
			} catch (Exception ex_1) {
				tpm_.deleteKey_(keyName);
				throw new KeyChain.Error("Invalid private key `" + keyName.toUri()
						+ "`");
			}
	
			PublicKey publicKey;
			try {
				publicKey = new PublicKey(publicKeyBits);
			} catch (UnrecognizedKeyFormatException ex_2) {
				// Promote to Pib.Error.
				tpm_.deleteKey_(keyName);
				throw new Pib.Error("Error decoding public key " + ex_2);
			}
			// TODO: Move verify into PublicKey?
			bool isVerified = false;
			try {
				if (publicKey.getKeyType() == net.named_data.jndn.security.KeyType.ECDSA) {
					KeyFactory keyFactory = System.KeyFactory.getInstance("EC");
					System.SecurityPublicKey publicKeyImpl = keyFactory
							.generatePublic(new X509EncodedKeySpec(publicKey
									.getKeyDer().getImmutableArray()));
					System.SecuritySignature signatureImpl = System.SecuritySignature
							.getInstance("SHA256withECDSA");
					signatureImpl.initVerify(publicKeyImpl);
					signatureImpl.update(content.buf());
					isVerified = signatureImpl.verify(signatureBits
							.getImmutableArray());
				} else if (publicKey.getKeyType() == net.named_data.jndn.security.KeyType.RSA) {
					KeyFactory keyFactory_3 = System.KeyFactory.getInstance("RSA");
					System.SecurityPublicKey publicKeyImpl_4 = keyFactory_3
							.generatePublic(new X509EncodedKeySpec(publicKey
									.getKeyDer().getImmutableArray()));
					System.SecuritySignature signatureImpl_5 = System.SecuritySignature
							.getInstance("SHA256withRSA");
					signatureImpl_5.initVerify(publicKeyImpl_4);
					signatureImpl_5.update(content.buf());
					isVerified = signatureImpl_5.verify(signatureBits
							.getImmutableArray());
				} else
					// We don't expect this.
					throw new AssertionError("Unrecognized key type");
			} catch (Exception ex_6) {
				// Promote to Pib.Error.
				tpm_.deleteKey_(keyName);
				throw new Pib.Error("Error verifying with the public key " + ex_6);
			}
	
			if (!isVerified) {
				tpm_.deleteKey_(keyName);
				throw new KeyChain.Error("Certificate `"
						+ certificate.getName().toUri() + "` and private key `"
						+ keyName.toUri() + "` do not match");
			}
	
			// The consistency is verified. Add to the PIB.
			PibIdentity id = pib_.addIdentity_(identity);
			PibKey key = id.addKey_(certificate.getPublicKey().buf(), keyName);
			key.addCertificate_(certificate);
		}
	
		/// <summary>
		/// Import a certificate and its corresponding private key encapsulated in a
		/// SafeBag, with a null password which imports an unencrypted PKCS #8
		/// PrivateKeyInfo. If the certificate and key are imported properly, the
		/// default setting will be updated as if a new key and certificate is added
		/// into this KeyChain.
		/// </summary>
		///
		/// <param name="safeBag"></param>
		/// <exception cref="KeyChain.Error">if the private key cannot be imported, or if apublic key or private key of the same name already exists, or if acertificate of the same name already exists.</exception>
		public void importSafeBag(SafeBag safeBag) {
			importSafeBag(safeBag, null);
		}
	
		// PIB & TPM backend registry
	
		/// <summary>
		/// Add to the PIB factories map where scheme is the key and makePibImpl is the
		/// value. If your application has its own PIB implementations, this must be
		/// called before creating a KeyChain instance which uses your PIB scheme.
		/// </summary>
		///
		/// <param name="scheme">The PIB scheme.</param>
		/// <param name="makePibImpl"></param>
		public static void registerPibBackend(String scheme, KeyChain.MakePibImpl  makePibImpl) {
			ILOG.J2CsMapping.Collections.Collections.Put(getPibFactories(),scheme,makePibImpl);
		}
	
		/// <summary>
		/// Add to the TPM factories map where scheme is the key and makeTpmBackEnd is
		/// the value. If your application has its own TPM implementations, this must
		/// be called before creating a KeyChain instance which uses your TPM scheme.
		/// </summary>
		///
		/// <param name="scheme">The TPM scheme.</param>
		/// <param name="makeTpmBackEnd"></param>
		public static void registerTpmBackend(String scheme,
				KeyChain.MakeTpmBackEnd  makeTpmBackEnd) {
			ILOG.J2CsMapping.Collections.Collections.Put(getTpmFactories(),scheme,makeTpmBackEnd);
		}
	
		// Security v1 methods
	
		/*****************************************
		 *          Identity Management          *
		 *****************************************/
	
		/// <summary>
		/// Create a security v1 identity by creating a pair of Key-Signing-Key (KSK)
		/// for this identity and a self-signed certificate of the KSK. If a key pair or
		/// certificate for the identity already exists, use it.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="params"></param>
		/// <returns>The name of the default certificate of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentityAndCertificate(Name identityName,
				KeyParams paras) {
			return identityManager_.createIdentityAndCertificate(identityName,
					paras);
		}
	
		/// <summary>
		/// Create a security v1 identity by creating a pair of Key-Signing-Key (KSK)
		/// for this identity and a self-signed certificate of the KSK. Use
		/// getDefaultKeyParams() to create the key if needed. If a key pair or
		/// certificate for the identity already exists, use it.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The name of the default certificate of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentityAndCertificate(Name identityName) {
			return createIdentityAndCertificate(identityName, getDefaultKeyParams());
		}
	
		/// <summary>
		/// Create a security v1 identity by creating a pair of Key-Signing-Key (KSK)
		/// for this identity and a self-signed certificate of the KSK.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="params"></param>
		/// <returns>The key name of the auto-generated KSK of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentity(Name identityName, KeyParams paras) {
			return net.named_data.jndn.security.certificate.IdentityCertificate
					.certificateNameToPublicKeyName(createIdentityAndCertificate(
							identityName, paras));
		}
	
		/// <summary>
		/// Create a security v1 identity by creating a pair of Key-Signing-Key (KSK)
		/// for this identity and a self-signed certificate of the KSK. Use
		/// getDefaultKeyParams() to create the key if needed.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The key name of the auto-generated KSK of the identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the identity has already been created.</exception>
		public Name createIdentity(Name identityName) {
			return net.named_data.jndn.security.certificate.IdentityCertificate
					.certificateNameToPublicKeyName(createIdentityAndCertificate(identityName));
		}
	
		/// <summary>
		/// Delete the identity from the public and private key storage. If the
		/// identity to be deleted is the current default system default, this will not
		/// delete the identity and will return immediately.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		public void deleteIdentity(Name identityName) {
			if (!isSecurityV1_) {
				try {
					deleteIdentity(pib_.getIdentity(identityName));
				} catch (Pib.Error ex) {
				} catch (PibImpl.Error ex_0) {
				} catch (TpmBackEnd.Error ex_1) {
				}
				return;
			}
	
			identityManager_.deleteIdentity(identityName);
		}
	
		/// <summary>
		/// Get the default identity.
		/// </summary>
		///
		/// <returns>The name of default identity.</returns>
		/// <exception cref="System.Security.SecurityException">if the default identity is not set.</exception>
		public Name getDefaultIdentity() {
			if (!isSecurityV1_) {
				try {
					return pib_.getDefaultIdentity().getName();
				} catch (PibImpl.Error ex) {
					throw new SecurityException("Error in getDefaultIdentity: "
							+ ex);
				} catch (Pib.Error ex_0) {
					throw new SecurityException("Error in getDefaultIdentity: "
							+ ex_0);
				}
			}
	
			return identityManager_.getDefaultIdentity();
		}
	
		/// <summary>
		/// Get the default certificate name of the default identity.
		/// </summary>
		///
		/// <returns>The requested certificate name.</returns>
		/// <exception cref="System.Security.SecurityException">if the default identity is not set or the defaultkey name for the identity is not set or the default certificate name forthe key name is not set.</exception>
		public Name getDefaultCertificateName() {
			if (!isSecurityV1_) {
				try {
					return pib_.getDefaultIdentity().getDefaultKey()
							.getDefaultCertificate().getName();
				} catch (PibImpl.Error ex) {
					throw new SecurityException("Error in getDefaultCertificate: "
							+ ex);
				} catch (Pib.Error ex_0) {
					throw new SecurityException("Error in getDefaultCertificate: "
							+ ex_0);
				}
			}
	
			return identityManager_.getDefaultCertificateName();
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPair(Name identityName, bool isKsk,
				int keySize) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateRSAKeyPair is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_
					.generateRSAKeyPair(identityName, isKsk, keySize);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and default keySize
		/// 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPair(Name identityName, bool isKsk) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateRSAKeyPair is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateRSAKeyPair(identityName, isKsk);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity for a
		/// Data-Signing-Key and default keySize 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPair(Name identityName) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateRSAKeyPair is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateRSAKeyPair(identityName);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPair(Name identityName, bool isKsk,
				int keySize) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateEcdsaKeyPair is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateEcdsaKeyPair(identityName, isKsk,
					keySize);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and default keySize
		/// 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPair(Name identityName, bool isKsk) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateEcdsaKeyPair is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateEcdsaKeyPair(identityName, isKsk);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity for a
		/// Data-Signing-Key and default keySize 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPair(Name identityName) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateEcdsaKeyPair is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateEcdsaKeyPair(identityName);
		}
	
		/// <summary>
		/// Set a key as the default key of an identity. The identity name is inferred
		/// from keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <param name="identityNameCheck"></param>
		public void setDefaultKeyForIdentity(Name keyName,
				Name identityNameCheck) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"setDefaultKeyForIdentity is not supported for security v2. Use getPib() methods.");
	
			identityManager_.setDefaultKeyForIdentity(keyName, identityNameCheck);
		}
	
		/// <summary>
		/// Set a key as the default key of an identity. The identity name is inferred
		/// from keyName.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		public void setDefaultKeyForIdentity(Name keyName) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"setDefaultKeyForIdentity is not supported for security v2. Use getPib() methods.");
	
			identityManager_.setDefaultKeyForIdentity(keyName);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and set it as the
		/// default key for the identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPairAsDefault(Name identityName,
				bool isKsk, int keySize) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateRSAKeyPairAsDefault is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateRSAKeyPairAsDefault(identityName,
					isKsk, keySize);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and set it as the
		/// default key for the identity, using the default keySize 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPairAsDefault(Name identityName,
				bool isKsk) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateRSAKeyPairAsDefault is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_
					.generateRSAKeyPairAsDefault(identityName, isKsk);
		}
	
		/// <summary>
		/// Generate a pair of RSA keys for the specified identity and set it as
		/// default key for the identity for a Data-Signing-Key and using the default
		/// keySize 2048.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateRSAKeyPairAsDefault(Name identityName) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateRSAKeyPairAsDefault is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateRSAKeyPairAsDefault(identityName);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and set it as
		/// default key for the identity.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <param name="keySize">The size of the key.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPairAsDefault(Name identityName,
				bool isKsk, int keySize) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateEcdsaKeyPairAsDefault is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateEcdsaKeyPairAsDefault(identityName,
					isKsk, keySize);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and set it as
		/// default key for the identity, using the default keySize 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <param name="isKsk">true for generating a Key-Signing-Key (KSK), false for a Data-Signing-Key (KSK).</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPairAsDefault(Name identityName,
				bool isKsk) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateEcdsaKeyPairAsDefault is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateEcdsaKeyPairAsDefault(identityName,
					isKsk);
		}
	
		/// <summary>
		/// Generate a pair of ECDSA keys for the specified identity and set it as
		/// default key for the identity for a Data-Signing-Key and using the default
		/// keySize 256.
		/// </summary>
		///
		/// <param name="identityName">The name of the identity.</param>
		/// <returns>The generated key name.</returns>
		public Name generateEcdsaKeyPairAsDefault(Name identityName) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"generateEcdsaKeyPairAsDefault is not supported for security v2. Use createIdentityV2.");
	
			return identityManager_.generateEcdsaKeyPairAsDefault(identityName);
		}
	
		/// <summary>
		/// Create a public key signing request.
		/// </summary>
		///
		/// <param name="keyName">The name of the key.</param>
		/// <returns>The signing request data.</returns>
		/// <exception cref="System.Security.SecurityException">if the keyName is not found.</exception>
		public Blob createSigningRequest(Name keyName) {
			if (!isSecurityV1_) {
				try {
					return pib_
							.getIdentity(net.named_data.jndn.security.pib.PibKey.extractIdentityFromKeyName(keyName))
							.getKey(keyName).getPublicKey();
				} catch (PibImpl.Error ex) {
					throw new SecurityException("Error in getKey: " + ex);
				} catch (Pib.Error ex_0) {
					throw new SecurityException("Error in getKey: " + ex_0);
				}
			}
	
			return identityManager_.getPublicKey(keyName).getKeyDer();
		}
	
		/// <summary>
		/// Install an identity certificate into the public key identity storage.
		/// </summary>
		///
		/// <param name="certificate">The certificate to to added.</param>
		public void installIdentityCertificate(IdentityCertificate certificate) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"installIdentityCertificate is not supported for security v2. Use getPib() methods.");
	
			identityManager_.addCertificate(certificate);
		}
	
		/// <summary>
		/// Set the certificate as the default for its corresponding key.
		/// </summary>
		///
		/// <param name="certificate">The certificate.</param>
		public void setDefaultCertificateForKey(
				IdentityCertificate certificate) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"setDefaultCertificateForKey is not supported for security v2. Use getPib() methods.");
	
			identityManager_.setDefaultCertificateForKey(certificate);
		}
	
		/// <summary>
		/// Get a certificate with the specified name.
		/// </summary>
		///
		/// <param name="certificateName">The name of the requested certificate.</param>
		/// <returns>The requested certificate.</returns>
		public IdentityCertificate getCertificate(Name certificateName) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"getCertificate is not supported for security v2. Use getPib() methods.");
	
			return identityManager_.getCertificate(certificateName);
		}
	
		public IdentityCertificate getIdentityCertificate(Name certificateName) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"getIdentityCertificate is not supported for security v2. Use getPib() methods.");
	
			return identityManager_.getCertificate(certificateName);
		}
	
		/// <summary>
		/// Revoke a key.
		/// </summary>
		///
		/// <param name="keyName">The name of the key that will be revoked.</param>
		public void revokeKey(Name keyName) {
			//TODO: Implement
		}
	
		/// <summary>
		/// Revoke a certificate.
		/// </summary>
		///
		/// <param name="certificateName">The name of the certificate that will be revoked.</param>
		public void revokeCertificate(Name certificateName) {
			//TODO: Implement
		}
	
		/// <summary>
		/// Get the identity manager given to or created by the constructor.
		/// </summary>
		///
		/// <returns>The identity manager.</returns>
		public IdentityManager getIdentityManager() {
			if (!isSecurityV1_)
				throw new AssertionError(
						"getIdentityManager is not supported for security v2");
	
			return identityManager_;
		}
	
		/*****************************************
		 *              Sign/Verify              *
		 *****************************************/
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="certificateName">The certificate name of the key to use for signing.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void sign(Data data, Name certificateName,
				WireFormat wireFormat) {
			if (!isSecurityV1_) {
				SigningInfo signingInfo = new SigningInfo();
				signingInfo.setSigningCertificateName(certificateName);
				try {
					sign(data, signingInfo, wireFormat);
				} catch (TpmBackEnd.Error ex) {
					throw new SecurityException("Error in sign: " + ex);
				} catch (PibImpl.Error ex_0) {
					throw new SecurityException("Error in sign: " + ex_0);
				} catch (KeyChain.Error  ex_1) {
					throw new SecurityException("Error in sign: " + ex_1);
				}
				return;
			}
	
			identityManager_.signByCertificate(data, certificateName, wireFormat);
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// Use the default WireFormat.getDefaultWireFormat()
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="certificateName">The certificate name of the key to use for signing.</param>
		public void sign(Data data, Name certificateName) {
			sign(data, certificateName, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Append a SignatureInfo to the Interest name, sign the name components and
		/// append a final name component with the signature bits.
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="certificateName">The certificate name of the key to use for signing.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void sign(Interest interest, Name certificateName,
				WireFormat wireFormat) {
			if (!isSecurityV1_) {
				SigningInfo signingInfo = new SigningInfo();
				signingInfo.setSigningCertificateName(certificateName);
				try {
					sign(interest, signingInfo, wireFormat);
				} catch (PibImpl.Error ex) {
					throw new SecurityException("Error in sign: " + ex);
				} catch (KeyChain.Error  ex_0) {
					throw new SecurityException("Error in sign: " + ex_0);
				} catch (TpmBackEnd.Error ex_1) {
					throw new SecurityException("Error in sign: " + ex_1);
				}
				return;
			}
	
			identityManager_.signInterestByCertificate(interest, certificateName,
					wireFormat);
		}
	
		/// <summary>
		/// Append a SignatureInfo to the Interest name, sign the name components and
		/// append a final name component with the signature bits.
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="certificateName">The certificate name of the key to use for signing.</param>
		public void sign(Interest interest, Name certificateName) {
			sign(interest, certificateName, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Sign the byte buffer using a certificate name and return a Signature object.
		/// </summary>
		///
		/// <param name="buffer">The byte array to be signed.</param>
		/// <param name="certificateName">The certificate name used to get the signing key and which will be put into KeyLocator.</param>
		/// <returns>The Signature.</returns>
		public Signature sign(ByteBuffer buffer, Name certificateName) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"sign(buffer, certificateName) is not supported for security v2. Use sign with SigningInfo.");
	
			return identityManager_.signByCertificate(buffer, certificateName);
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="identityName"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input. If omitted, use WireFormat getDefaultWireFormat().</param>
		public void signByIdentity(Data data, Name identityName,
				WireFormat wireFormat) {
			if (!isSecurityV1_) {
				SigningInfo signingInfo = new SigningInfo();
				signingInfo.setSigningIdentity(identityName);
				try {
					sign(data, signingInfo, wireFormat);
				} catch (TpmBackEnd.Error ex) {
					throw new SecurityException("Error in sign: " + ex);
				} catch (PibImpl.Error ex_0) {
					throw new SecurityException("Error in sign: " + ex_0);
				} catch (KeyChain.Error  ex_1) {
					throw new SecurityException("Error in sign: " + ex_1);
				}
				return;
			}
	
			Name signingCertificateName;
	
			if (identityName.size() == 0) {
				Name inferredIdentity = policyManager_.inferSigningIdentity(data
						.getName());
				if (inferredIdentity.size() == 0)
					signingCertificateName = identityManager_
							.getDefaultCertificateName();
				else
					signingCertificateName = identityManager_
							.getDefaultCertificateNameForIdentity(inferredIdentity);
			} else
				signingCertificateName = identityManager_
						.getDefaultCertificateNameForIdentity(identityName);
	
			if (signingCertificateName.size() == 0)
				throw new SecurityException("No qualified certificate name found!");
	
			if (!policyManager_.checkSigningPolicy(data.getName(),
					signingCertificateName))
				throw new SecurityException(
						"Signing Cert name does not comply with signing policy");
	
			identityManager_.signByCertificate(data, signingCertificateName,
					wireFormat);
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// </summary>
		///
		/// <param name="data">Use the default WireFormat.getDefaultWireFormat().</param>
		/// <param name="identityName"></param>
		public void signByIdentity(Data data, Name identityName) {
			signByIdentity(data, identityName, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Wire encode the Data object, sign it and set its signature.
		/// </summary>
		///
		/// <param name="data">Infer the signing identity from the data packet name. Use the default WireFormat.getDefaultWireFormat().</param>
		public void signByIdentity(Data data) {
			signByIdentity(data, new Name(), net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Sign the byte buffer using an identity name and return a Signature object.
		/// </summary>
		///
		/// <param name="buffer">The byte array to be signed.</param>
		/// <param name="identityName">The identity name.</param>
		/// <returns>The Signature.</returns>
		public Signature signByIdentity(ByteBuffer buffer, Name identityName) {
			if (!isSecurityV1_)
				throw new SecurityException(
						"signByIdentity(buffer, identityName) is not supported for security v2. Use sign with SigningInfo.");
	
			Name signingCertificateName = identityManager_
					.getDefaultCertificateNameForIdentity(identityName);
	
			if (signingCertificateName.size() == 0)
				throw new SecurityException("No qualified certificate name found!");
	
			return identityManager_.signByCertificate(buffer,
					signingCertificateName);
		}
	
		/// <summary>
		/// Wire encode the Data object, digest it and set its SignatureInfo to
		/// a DigestSha256.
		/// </summary>
		///
		/// <param name="data"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void signWithSha256(Data data, WireFormat wireFormat) {
			if (!isSecurityV1_) {
				SigningInfo signingInfo = new SigningInfo();
				signingInfo.setSha256Signing();
				try {
					sign(data, signingInfo, wireFormat);
				} catch (TpmBackEnd.Error ex) {
					throw new SecurityException("Error in sign: " + ex);
				} catch (PibImpl.Error ex_0) {
					throw new SecurityException("Error in sign: " + ex_0);
				} catch (KeyChain.Error  ex_1) {
					throw new SecurityException("Error in sign: " + ex_1);
				}
				return;
			}
	
			identityManager_.signWithSha256(data, wireFormat);
		}
	
		/// <summary>
		/// Wire encode the Data object, digest it and set its SignatureInfo to
		/// a DigestSha256.
		/// </summary>
		///
		/// <param name="data"></param>
		public void signWithSha256(Data data) {
			signWithSha256(data, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Append a SignatureInfo for DigestSha256 to the Interest name, digest the
		/// name components and append a final name component with the signature bits
		/// (which is the digest).
		/// </summary>
		///
		/// <param name="interest"></param>
		/// <param name="wireFormat">A WireFormat object used to encode the input.</param>
		public void signWithSha256(Interest interest, WireFormat wireFormat) {
			if (!isSecurityV1_) {
				SigningInfo signingInfo = new SigningInfo();
				signingInfo.setSha256Signing();
				try {
					sign(interest, signingInfo, wireFormat);
				} catch (PibImpl.Error ex) {
					throw new SecurityException("Error in sign: " + ex);
				} catch (KeyChain.Error  ex_0) {
					throw new SecurityException("Error in sign: " + ex_0);
				} catch (TpmBackEnd.Error ex_1) {
					throw new SecurityException("Error in sign: " + ex_1);
				}
				return;
			}
	
			identityManager_.signInterestWithSha256(interest, wireFormat);
		}
	
		/// <summary>
		/// Append a SignatureInfo for DigestSha256 to the Interest name, digest the
		/// name components and append a final name component with the signature bits
		/// (which is the digest).
		/// </summary>
		///
		/// <param name="interest"></param>
		public void signWithSha256(Interest interest) {
			signWithSha256(interest, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		public void verifyData(Data data, OnVerified onVerified,
				OnDataValidationFailed onValidationFailed, int stepCount) {
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger(this.GetType().FullName).log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
					"Enter Verify");
	
			if (policyManager_.requireVerify(data)) {
				ValidationRequest nextStep = policyManager_
						.checkVerificationPolicy(data, stepCount, onVerified,
								onValidationFailed);
				if (nextStep != null) {
					KeyChain.VerifyCallbacks  callbacks = new KeyChain.VerifyCallbacks (this, nextStep,
							nextStep.retry_, onValidationFailed, data);
					try {
						face_.expressInterest(nextStep.interest_, callbacks,
								callbacks);
					} catch (IOException ex) {
						try {
							onValidationFailed.onDataValidationFailed(data,
									"Error calling expressInterest " + ex);
						} catch (Exception exception) {
							logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onDataValidationFailed", exception);
						}
					}
				}
			} else if (policyManager_.skipVerifyAndTrust(data)) {
				try {
					onVerified.onVerified(data);
				} catch (Exception ex_0) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onVerified", ex_0);
				}
			} else {
				try {
					onValidationFailed
							.onDataValidationFailed(data,
									"The packet has no verify rule but skipVerifyAndTrust is false");
				} catch (Exception ex_1) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onDataValidationFailed", ex_1);
				}
			}
		}
	
		/// <summary>
		/// Check the signature on the Data object and call either onVerify.onVerify or
		/// onValidationFailed.onDataValidationFailed.
		/// We use callback functions because verify may fetch information to check the
		/// signature.
		/// </summary>
		///
		/// <param name="data">To set the wireEncoding, you can call data.wireDecode.</param>
		/// <param name="onVerified">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onValidationFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public void verifyData(Data data, OnVerified onVerified,
				OnDataValidationFailed onValidationFailed) {
			verifyData(data, onVerified, onValidationFailed, 0);
		}
	
		/// <summary>
		/// Check the signature on the Data object and call either onVerify.onVerify or
		/// onVerifyFailed.onVerifyFailed.
		/// We use callback functions because verify may fetch information to check the
		/// signature.
		/// </summary>
		///
		/// <param name="data">To set the wireEncoding, you can call data.wireDecode.</param>
		/// <param name="onVerified">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onVerifyFailed_0">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public void verifyData(Data data, OnVerified onVerified,
				OnVerifyFailed onVerifyFailed_0) {
			// Wrap the onVerifyFailed in an OnDataValidationFailed.
			verifyData(data, onVerified, new KeyChain.Anonymous_C5 (onVerifyFailed_0));
		}
	
		public void verifyInterest(Interest interest,
				OnVerifiedInterest onVerified,
				OnInterestValidationFailed onValidationFailed, int stepCount) {
			ILOG.J2CsMapping.Util.Logging.Logger.getLogger(this.GetType().FullName).log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
					"Enter Verify");
	
			if (policyManager_.requireVerify(interest)) {
				ValidationRequest nextStep = policyManager_
						.checkVerificationPolicy(interest, stepCount, onVerified,
								onValidationFailed);
				if (nextStep != null) {
					KeyChain.VerifyCallbacksForVerifyInterest  callbacks = new KeyChain.VerifyCallbacksForVerifyInterest (
							this, nextStep, nextStep.retry_, onValidationFailed, interest);
					try {
						face_.expressInterest(nextStep.interest_, callbacks,
								callbacks);
					} catch (IOException ex) {
						try {
							onValidationFailed.onInterestValidationFailed(interest,
									"Error calling expressInterest " + ex);
						} catch (Exception exception) {
							logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onInterestValidationFailed",
									exception);
						}
					}
				}
			} else if (policyManager_.skipVerifyAndTrust(interest)) {
				try {
					onVerified.onVerifiedInterest(interest);
				} catch (Exception ex_0) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onVerifiedInterest", ex_0);
				}
			} else {
				try {
					onValidationFailed
							.onInterestValidationFailed(interest,
									"The packet has no verify rule but skipVerifyAndTrust is false");
				} catch (Exception ex_1) {
					logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
							"Error in onInterestValidationFailed", ex_1);
				}
			}
		}
	
		/// <summary>
		/// Check the signature on the signed interest and call either
		/// onVerify.onVerifiedInterest or 
		/// onValidationFailed.onInterestValidationFailed. We
		/// use callback functions because verify may fetch information to check the
		/// signature.
		/// </summary>
		///
		/// <param name="interest">The interest with the signature to check.</param>
		/// <param name="onVerified">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onValidationFailed">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public void verifyInterest(Interest interest,
				OnVerifiedInterest onVerified,
				OnInterestValidationFailed onValidationFailed) {
			verifyInterest(interest, onVerified, onValidationFailed, 0);
		}
	
		/// <summary>
		/// Check the signature on the signed interest and call either
		/// onVerify.onVerifiedInterest or onVerifyFailed.onVerifyInterestFailed. We
		/// use callback functions because verify may fetch information to check the
		/// signature.
		/// </summary>
		///
		/// <param name="interest">The interest with the signature to check.</param>
		/// <param name="onVerified">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="onVerifyFailed_0">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		public void verifyInterest(Interest interest,
				OnVerifiedInterest onVerified,
				OnVerifyInterestFailed onVerifyFailed_0) {
			// Wrap the onVerifyFailed in an OnInterestValidationFailed.
			verifyInterest(interest, onVerified, new KeyChain.Anonymous_C4 (onVerifyFailed_0));
		}
	
		/// <summary>
		/// Set the Face which will be used to fetch required certificates.
		/// </summary>
		///
		/// <param name="face">The Face object.</param>
		public void setFace(Face face) {
			face_ = face;
		}
	
		/// <summary>
		/// Wire encode the data packet, compute an HmacWithSha256 and update the
		/// signature value.
		/// </summary>
		///
		/// @note This method is an experimental feature. The API may change.
		/// <param name="data">The Data object to be signed. This updates its signature.</param>
		/// <param name="key">The key for the HmacWithSha256.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the data packet.</param>
		public static void signWithHmacWithSha256(Data data, Blob key,
				WireFormat wireFormat) {
			// Encode once to get the signed portion.
			SignedBlob encoding = data.wireEncode(wireFormat);
			byte[] signatureBytes = net.named_data.jndn.util.Common.computeHmacWithSha256(
					key.getImmutableArray(), encoding.signedBuf());
			data.getSignature().setSignature(new Blob(signatureBytes, false));
		}
	
		/// <summary>
		/// Wire encode the data packet, compute an HmacWithSha256 and update the
		/// signature value.
		/// Use the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// @note This method is an experimental feature. The API may change.
		/// <param name="data">The Data object to be signed. This updates its signature.</param>
		/// <param name="key">The key for the HmacWithSha256.</param>
		public static void signWithHmacWithSha256(Data data, Blob key) {
			signWithHmacWithSha256(data, key, net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		/// <summary>
		/// Compute a new HmacWithSha256 for the data packet and verify it against the
		/// signature value.
		/// </summary>
		///
		/// @note This method is an experimental feature. The API may change.
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="key">The key for the HmacWithSha256.</param>
		/// <param name="wireFormat">A WireFormat object used to encode the data packet.</param>
		/// <returns>True if the signature verifies, otherwise false.</returns>
		public static bool verifyDataWithHmacWithSha256(Data data, Blob key,
				WireFormat wireFormat) {
			// wireEncode returns the cached encoding if available.
			SignedBlob encoding = data.wireEncode(wireFormat);
			byte[] newSignatureBytes = net.named_data.jndn.util.Common.computeHmacWithSha256(
					key.getImmutableArray(), encoding.signedBuf());
	
			return ILOG.J2CsMapping.NIO.ByteBuffer.wrap(newSignatureBytes).equals(
					data.getSignature().getSignature().buf());
		}
	
		/// <summary>
		/// Compute a new HmacWithSha256 for the data packet and verify it against the
		/// signature value.
		/// Use the default WireFormat.getDefaultWireFormat().
		/// </summary>
		///
		/// @note This method is an experimental feature. The API may change.
		/// <param name="data">The Data packet to verify.</param>
		/// <param name="key">The key for the HmacWithSha256.</param>
		/// <returns>True if the signature verifies, otherwise false.</returns>
		public static bool verifyDataWithHmacWithSha256(Data data, Blob key) {
			return verifyDataWithHmacWithSha256(data, key,
					net.named_data.jndn.encoding.WireFormat.getDefaultWireFormat());
		}
	
		public static KeyParams getDefaultKeyParams() {
			return defaultKeyParams_;
		}
	
		public static readonly RsaKeyParams DEFAULT_KEY_PARAMS = new RsaKeyParams();
	
		// Private security v2 methods
	
		/// <summary>
		/// Do the work of the constructor.
		/// </summary>
		///
		private void construct(String pibLocator, String tpmLocator,
				bool allowReset) {
			// PIB locator.
			String[] pibScheme = new String[1];
			String[] pibLocation = new String[1];
			parseAndCheckPibLocator(pibLocator, pibScheme, pibLocation);
			String canonicalPibLocator = pibScheme[0] + ":" + pibLocation[0];
	
			// Create the PIB.
			pib_ = createPib(canonicalPibLocator);
			String oldTpmLocator = "";
			try {
				oldTpmLocator = pib_.getTpmLocator();
			} catch (Pib.Error ex) {
				// The TPM locator is not set in the PIB yet.
			}
	
			// TPM locator.
			String[] tpmScheme = new String[1];
			String[] tpmLocation = new String[1];
			parseAndCheckTpmLocator(tpmLocator, tpmScheme, tpmLocation);
			String canonicalTpmLocator = tpmScheme[0] + ":" + tpmLocation[0];
	
			ConfigFile config = new ConfigFile();
			if (canonicalPibLocator.equals(getDefaultPibLocator(config))) {
				// The default PIB must use the default TPM.
				if (!oldTpmLocator.equals("")
						&& !oldTpmLocator.equals(getDefaultTpmLocator(config))) {
					pib_.reset_();
					canonicalTpmLocator = getDefaultTpmLocator(config);
				}
			} else {
				// Check the consistency of the non-default PIB.
				if (!oldTpmLocator.equals("")
						&& !oldTpmLocator.equals(canonicalTpmLocator)) {
					if (allowReset)
						pib_.reset_();
					else
						throw new KeyChain.LocatorMismatchError (
								"The supplied TPM locator does not match the TPM locator in the PIB: "
										+ oldTpmLocator + " != "
										+ canonicalTpmLocator);
				}
			}
	
			// Note that a key mismatch may still happen if the TPM locator is initially
			// set to a wrong one or if the PIB was shared by more than one TPM before.
			// This is due to the old PIB not having TPM info. The new PIB should not
			// have this problem.
			tpm_ = createTpm(canonicalTpmLocator);
			pib_.setTpmLocator(canonicalTpmLocator);
		}
	
		/// <summary>
		/// Get the PIB factories map. On the first call, this initializes the map with
		/// factories for standard PibImpl implementations.
		/// </summary>
		///
		/// <returns>A map where the key is the scheme string and the value is the
		/// object implementing makePibImpl.</returns>
		private static Hashtable<String, MakePibImpl> getPibFactories() {
			if (pibFactories_ == null) {
				pibFactories_ = new Hashtable<String, MakePibImpl>();
	
				// Add the standard factories.
				ILOG.J2CsMapping.Collections.Collections.Put(pibFactories_,net.named_data.jndn.security.pib.PibSqlite3.getScheme(),new KeyChain.Anonymous_C3 ());
				ILOG.J2CsMapping.Collections.Collections.Put(pibFactories_,net.named_data.jndn.security.pib.PibMemory.getScheme(),new KeyChain.Anonymous_C2 ());
			}
	
			return pibFactories_;
		}
	
		/// <summary>
		/// Get the TPM factories map. On the first call, this initializes the map with
		/// factories for standard TpmBackEnd implementations.
		/// </summary>
		///
		/// <returns>A map where the key is the scheme string and the value is the
		/// object implementing makeTpmBackEnd.</returns>
		private static Hashtable<String, MakeTpmBackEnd> getTpmFactories() {
			if (tpmFactories_ == null) {
				tpmFactories_ = new Hashtable<String, MakeTpmBackEnd>();
	
				// Add the standard factories.
				ILOG.J2CsMapping.Collections.Collections.Put(tpmFactories_,net.named_data.jndn.security.tpm.TpmBackEndFile.getScheme(),new KeyChain.Anonymous_C1 ());
				ILOG.J2CsMapping.Collections.Collections.Put(tpmFactories_,net.named_data.jndn.security.tpm.TpmBackEndMemory.getScheme(),new KeyChain.Anonymous_C0 ());
			}
	
			return tpmFactories_;
		}
	
		/// <summary>
		/// Parse the uri and set the scheme and location.
		/// </summary>
		///
		/// <param name="uri">The URI to parse.</param>
		/// <param name="scheme">Set scheme[0] to the scheme.</param>
		/// <param name="location">Set location[0] to the location.</param>
		private static void parseLocatorUri(String uri, String[] scheme,
				String[] location) {
			int iColon = uri.indexOf(':');
			if (iColon >= 0) {
				scheme[0] = uri.Substring(0,(iColon)-(0));
				location[0] = uri.Substring(iColon + 1);
			} else {
				scheme[0] = uri;
				location[0] = "";
			}
		}
	
		/// <summary>
		/// Parse the pibLocator and set the pibScheme and pibLocation.
		/// </summary>
		///
		/// <param name="pibLocator">The PIB locator to parse.</param>
		/// <param name="pibScheme">Set pibScheme[0] to the PIB scheme.</param>
		/// <param name="pibLocation">Set pibLocation[0] to the PIB location.</param>
		private static void parseAndCheckPibLocator(String pibLocator,
				String[] pibScheme, String[] pibLocation) {
			parseLocatorUri(pibLocator, pibScheme, pibLocation);
	
			if (pibScheme[0].equals(""))
				pibScheme[0] = getDefaultPibScheme();
	
			if (!getPibFactories().Contains(pibScheme[0]))
				throw new KeyChain.Error("PIB scheme `" + pibScheme[0]
						+ "` is not supported");
		}
	
		/// <summary>
		/// Parse the tpmLocator and set the tpmScheme and tpmLocation.
		/// </summary>
		///
		/// <param name="tpmLocator">The TPM locator to parse.</param>
		/// <param name="tpmScheme">Set tpmScheme[0] to the TPM scheme.</param>
		/// <param name="tpmLocation">Set tpmLocation[0] to the TPM location.</param>
		private static void parseAndCheckTpmLocator(String tpmLocator,
				String[] tpmScheme, String[] tpmLocation) {
			parseLocatorUri(tpmLocator, tpmScheme, tpmLocation);
	
			if (tpmScheme[0].equals(""))
				tpmScheme[0] = getDefaultTpmScheme();
	
			if (!getTpmFactories().Contains(tpmScheme[0]))
				throw new KeyChain.Error("TPM scheme `" + tpmScheme[0]
						+ "` is not supported");
		}
	
		private static String getDefaultPibScheme() {
			return net.named_data.jndn.security.pib.PibSqlite3.getScheme();
		}
	
		private static String getDefaultTpmScheme() {
			if (net.named_data.jndn.util.Common.platformIsOSX())
				throw new SecurityException(
						"TpmBackEndOsx is not implemented yet. You must use tpm-file.");
	
			return net.named_data.jndn.security.tpm.TpmBackEndFile.getScheme();
		}
	
		/// <summary>
		/// Create a Pib according to the pibLocator
		/// </summary>
		///
		/// <param name="pibLocator">The PIB locator, e.g., "pib-sqlite3:/example/dir".</param>
		/// <returns>A new Pib object.</returns>
		private static Pib createPib(String pibLocator) {
			String[] pibScheme = new String[1];
			String[] pibLocation = new String[1];
			parseAndCheckPibLocator(pibLocator, pibScheme, pibLocation);
			KeyChain.MakePibImpl  pibFactory = ILOG.J2CsMapping.Collections.Collections.Get(getPibFactories(),pibScheme[0]);
			return new Pib(pibScheme[0], pibLocation[0],
					pibFactory.makePibImpl(pibLocation[0]));
		}
	
		/// <summary>
		/// Create a Tpm according to the tpmLocator
		/// </summary>
		///
		/// <param name="tpmLocator">The TPM locator, e.g., "tpm-memory:".</param>
		/// <returns>A new Tpm object.</returns>
		private static Tpm createTpm(String tpmLocator) {
			String[] tpmScheme = new String[1];
			String[] tpmLocation = new String[1];
			parseAndCheckTpmLocator(tpmLocator, tpmScheme, tpmLocation);
			KeyChain.MakeTpmBackEnd  tpmFactory = ILOG.J2CsMapping.Collections.Collections.Get(getTpmFactories(),tpmScheme[0]);
			return new Tpm(tpmScheme[0], tpmLocation[0],
					tpmFactory.makeTpmBackEnd(tpmLocation[0]));
		}
	
		private static String getDefaultPibLocator(ConfigFile config) {
			if (defaultPibLocator_ != null)
				return defaultPibLocator_;
	
			String clientPib = System.Environment.GetEnvironmentVariable("NDN_CLIENT_PIB");
			if (clientPib != null && clientPib != "")
				defaultPibLocator_ = clientPib;
			else
				defaultPibLocator_ = config.get("pib", getDefaultPibScheme() + ":");
	
			return defaultPibLocator_;
		}
	
		private static String getDefaultTpmLocator(ConfigFile config) {
			if (defaultTpmLocator_ != null)
				return defaultTpmLocator_;
	
			String clientTpm = System.Environment.GetEnvironmentVariable("NDN_CLIENT_TPM");
			if (clientTpm != null && clientTpm != "")
				defaultTpmLocator_ = clientTpm;
			else
				defaultTpmLocator_ = config.get("tpm", getDefaultTpmScheme() + ":");
	
			return defaultTpmLocator_;
		}
	
		/// <summary>
		/// Prepare a Signature object according to signingInfo and get the signing key
		/// name.
		/// </summary>
		///
		/// <param name="params">The signing parameters.</param>
		/// <param name="keyName">Set keyName[0] to the signing key name.</param>
		/// <returns>A new Signature object with the SignatureInfo.</returns>
		/// <exception cref="InvalidSigningInfoError">when the requested signing method cannot besatisfied.</exception>
		private Signature prepareSignatureInfo(SigningInfo paras, Name[] keyName) {
			PibIdentity identity = null;
			PibKey key = null;
	
			if (paras.getSignerType() == net.named_data.jndn.security.SigningInfo.SignerType.NULL) {
				try {
					identity = pib_.getDefaultIdentity();
				} catch (Pib.Error ex) {
					// There is no default identity, so use sha256 for signing.
					keyName[0] = net.named_data.jndn.security.SigningInfo.getDigestSha256Identity();
					return new DigestSha256Signature();
				}
			} else if (paras.getSignerType() == net.named_data.jndn.security.SigningInfo.SignerType.ID) {
				identity = paras.getPibIdentity();
				if (identity == null) {
					try {
						identity = pib_.getIdentity(paras.getSignerName());
					} catch (Pib.Error ex_0) {
						throw new KeyChain.InvalidSigningInfoError ("Signing identity `"
								+ paras.getSignerName().toUri()
								+ "` does not exist");
					}
				}
			} else if (paras.getSignerType() == net.named_data.jndn.security.SigningInfo.SignerType.KEY) {
				key = paras.getPibKey();
				if (key == null) {
					Name identityName = net.named_data.jndn.security.pib.PibKey.extractIdentityFromKeyName(paras
							.getSignerName());
	
					try {
						identity = pib_.getIdentity(identityName);
						key = identity.getKey(paras.getSignerName());
						// We will use the PIB key instance, so reset the identity.
						identity = null;
					} catch (Pib.Error ex_1) {
						throw new KeyChain.InvalidSigningInfoError ("Signing key `"
								+ paras.getSignerName().toUri()
								+ "` does not exist");
					}
				}
			} else if (paras.getSignerType() == net.named_data.jndn.security.SigningInfo.SignerType.CERT) {
				Name identityName_2 = net.named_data.jndn.security.v2.CertificateV2
						.extractIdentityFromCertName(paras.getSignerName());
	
				try {
					identity = pib_.getIdentity(identityName_2);
					key = identity.getKey(net.named_data.jndn.security.v2.CertificateV2
							.extractKeyNameFromCertName(paras.getSignerName()));
				} catch (Pib.Error ex_3) {
					throw new KeyChain.InvalidSigningInfoError ("Signing certificate `"
							+ paras.getSignerName().toUri() + "` does not exist");
				}
			} else if (paras.getSignerType() == net.named_data.jndn.security.SigningInfo.SignerType.SHA256) {
				keyName[0] = net.named_data.jndn.security.SigningInfo.getDigestSha256Identity();
				return new DigestSha256Signature();
			} else
				// We don't expect this to happen.
				throw new KeyChain.InvalidSigningInfoError ("Unrecognized signer type");
	
			if (identity == null && key == null)
				throw new KeyChain.InvalidSigningInfoError (
						"Cannot determine signing parameters");
	
			if (identity != null && key == null) {
				try {
					key = identity.getDefaultKey();
				} catch (Pib.Error ex_4) {
					throw new KeyChain.InvalidSigningInfoError ("Signing identity `"
							+ identity.getName().toUri()
							+ "` does not have default certificate");
				}
			}
	
			Signature signatureInfo;
	
			if (key.getKeyType() == net.named_data.jndn.security.KeyType.RSA)
				signatureInfo = new Sha256WithRsaSignature();
			else if (key.getKeyType() == net.named_data.jndn.security.KeyType.ECDSA)
				signatureInfo = new Sha256WithEcdsaSignature();
			else
				throw new KeyChain.Error("Unsupported key type");
	
			KeyLocator keyLocator = net.named_data.jndn.KeyLocator.getFromSignature(signatureInfo);
			keyLocator.setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
			keyLocator.setKeyName(key.getName());
	
			keyName[0] = key.getName();
			return signatureInfo;
		}
	
		/// <summary>
		/// Sign the byte array using the key with name keyName.
		/// </summary>
		///
		/// <param name="buffer">The byte buffer to be signed.</param>
		/// <param name="keyName">The name of the key.</param>
		/// <param name="digestAlgorithm">The digest algorithm.</param>
		/// <returns>The signature Blob, or an isNull Blob if the key does not exist, or
		/// for an unrecognized digestAlgorithm.</returns>
		private Blob sign(ByteBuffer buffer, Name keyName,
				DigestAlgorithm digestAlgorithm) {
			if (keyName.equals(net.named_data.jndn.security.SigningInfo.getDigestSha256Identity()))
				return new Blob(net.named_data.jndn.util.Common.digestSha256(buffer));
	
			return tpm_.sign(buffer, keyName, digestAlgorithm);
		}
	
		// Private security v1 methods
	
		/// <summary>
		/// A VerifyCallbacks is used for callbacks from verifyData.
		/// </summary>
		///
			internal class VerifyCallbacks : OnData, OnTimeout {
				private KeyChain outer_KeyChain;
				public VerifyCallbacks(KeyChain chain, ValidationRequest nextStep, int retry,
						OnDataValidationFailed onValidationFailed, Data originalData) {
					outer_KeyChain = chain;
					nextStep_ = nextStep;
					retry_ = retry;
					onValidationFailed_ = onValidationFailed;
					originalData_ = originalData;
				}
		
				public void onData(Interest interest, Data data) {
					try {
						// Try to verify the certificate (data) according to the parameters in
						//   nextStep.
						outer_KeyChain.verifyData(data, nextStep_.onVerified_,
								nextStep_.onValidationFailed_, nextStep_.stepCount_);
					} catch (SecurityException ex) {
						ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(KeyChain).FullName).log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
								null, ex);
					}
				}
		
				public void onTimeout(Interest interest) {
					if (retry_ > 0) {
						// Issue the same expressInterest as in verifyData except decrement
						//   retry.
						KeyChain.VerifyCallbacks  callbacks = new KeyChain.VerifyCallbacks (outer_KeyChain, nextStep_,
								retry_ - 1, onValidationFailed_, originalData_);
						try {
							outer_KeyChain.face_.expressInterest(interest, callbacks, callbacks);
						} catch (IOException ex) {
							try {
								onValidationFailed_.onDataValidationFailed(
										originalData_,
										"Error in expressInterest to retry after timeout for fetching "
												+ interest.getName().toUri() + ": "
												+ ex);
							} catch (Exception exception) {
								net.named_data.jndn.security.KeyChain.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onDataValidationFailed", exception);
							}
						}
					} else {
						try {
							onValidationFailed_.onDataValidationFailed(originalData_,
									"The retry count is zero after timeout for fetching "
											+ interest.getName().toUri());
						} catch (Exception ex_0) {
							net.named_data.jndn.security.KeyChain.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onDataValidationFailed", ex_0);
						}
					}
				}
		
				private readonly ValidationRequest nextStep_;
				private readonly int retry_;
				private readonly OnDataValidationFailed onValidationFailed_;
				private readonly Data originalData_;
			}
	
		/// <summary>
		/// A VerifyCallbacksForVerifyInterest is used for callbacks from verifyInterest.
		/// This is the same as VerifyCallbacks, but we call
		/// onValidationFailed.onInterestValidationFailed(originalInterest, reason) if
		/// we have too many retries.
		/// </summary>
		///
			internal class VerifyCallbacksForVerifyInterest : OnData, OnTimeout {
				private KeyChain outer_KeyChain;
				public VerifyCallbacksForVerifyInterest(KeyChain chain, ValidationRequest nextStep,
						int retry, OnInterestValidationFailed onValidationFailed,
						Interest originalInterest) {
					outer_KeyChain = chain;
					nextStep_ = nextStep;
					retry_ = retry;
					onValidationFailed_ = onValidationFailed;
					originalInterest_ = originalInterest;
				}
		
				public void onData(Interest interest, Data data) {
					try {
						// Try to verify the certificate (data) according to the parameters in
						//   nextStep.
						outer_KeyChain.verifyData(data, nextStep_.onVerified_,
								nextStep_.onValidationFailed_, nextStep_.stepCount_);
					} catch (SecurityException ex) {
						ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(KeyChain).FullName).log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
								null, ex);
					}
				}
		
				public void onTimeout(Interest interest) {
					if (retry_ > 0) {
						// Issue the same expressInterest as in verifyData except decrement
						//   retry.
						KeyChain.VerifyCallbacksForVerifyInterest  callbacks = new KeyChain.VerifyCallbacksForVerifyInterest (
								outer_KeyChain, nextStep_, retry_ - 1, onValidationFailed_,
								originalInterest_);
						try {
							outer_KeyChain.face_.expressInterest(interest, callbacks, callbacks);
						} catch (IOException ex) {
							try {
								onValidationFailed_.onInterestValidationFailed(
										originalInterest_,
										"Error in expressInterest to retry after timeout for fetching "
												+ interest.getName().toUri() + ": "
												+ ex);
							} catch (Exception exception) {
								net.named_data.jndn.security.KeyChain.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
										"Error in onInterestValidationFailed",
										exception);
							}
						}
					} else {
						try {
							onValidationFailed_.onInterestValidationFailed(
									originalInterest_,
									"The retry count is zero after timeout for fetching "
											+ interest.getName().toUri());
						} catch (Exception ex_0) {
							net.named_data.jndn.security.KeyChain.logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
									"Error in onInterestValidationFailed", ex_0);
						}
					}
				}
		
				private readonly ValidationRequest nextStep_;
				private readonly int retry_;
				private readonly OnInterestValidationFailed onValidationFailed_;
				private readonly Interest originalInterest_;
			}
	
		/// <summary>
		/// Get the default certificate from the identity storage and return its name.
		/// If there is no default identity or default certificate, then create one.
		/// </summary>
		///
		/// <returns>The default certificate name.</returns>
		private Name prepareDefaultCertificateName() {
			IdentityCertificate signingCertificate = identityManager_
					.getDefaultCertificate();
			if (signingCertificate == null) {
				setDefaultCertificate();
				signingCertificate = identityManager_.getDefaultCertificate();
			}
	
			return signingCertificate.getName();
		}
	
		/// <summary>
		/// Create the default certificate if it is not initialized. If there is no
		/// default identity yet, creating a new tmp-identity.
		/// </summary>
		///
		private void setDefaultCertificate() {
			if (identityManager_.getDefaultCertificate() == null) {
				Name defaultIdentity;
				try {
					defaultIdentity = identityManager_.getDefaultIdentity();
				} catch (SecurityException e) {
					// Create a default identity name.
					ByteBuffer randomComponent = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(4);
					net.named_data.jndn.util.Common.getRandom().nextBytes(randomComponent.array());
					defaultIdentity = new Name().append("tmp-identity").append(
							new Blob(randomComponent, false));
				}
	
				createIdentityAndCertificate(defaultIdentity);
				identityManager_.setDefaultIdentity(defaultIdentity);
			}
		}
	
		private bool isSecurityV1_;
	
		private IdentityManager identityManager_; // for security v1
		private PolicyManager policyManager_; // for security v1
		internal Face face_; // for security v1
	
		private Pib pib_;
		private Tpm tpm_;
	
		private static String defaultPibLocator_ = null;
		private static String defaultTpmLocator_ = null;
		private static Hashtable<String, MakePibImpl> pibFactories_ = null;
		private static Hashtable<String, MakeTpmBackEnd> tpmFactories_ = null;
		private static readonly SigningInfo defaultSigningInfo_ = new SigningInfo();
		private static readonly KeyParams defaultKeyParams_ = new RsaKeyParams();
	
		static internal readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger.getLogger(typeof(KeyChain).FullName);
	}
}
