// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.sync.detail {
	
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.in_memory_storage;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.pib;
	using net.named_data.jndn.security.tpm;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// The PSyncSegmentPublisher class has methods to publish segmented data used by
	/// PSync.
	/// </summary>
	///
	public class PSyncSegmentPublisher {
		public sealed class Anonymous_C0 : IRunnable {
				private readonly PSyncSegmentPublisher outer_PSyncSegmentPublisher;
				private readonly Name segmentName;
		
				public Anonymous_C0(
						PSyncSegmentPublisher paramouter_PSyncSegmentPublisher,
						Name segmentName_0) {
					this.segmentName = segmentName_0;
					this.outer_PSyncSegmentPublisher = paramouter_PSyncSegmentPublisher;
				}
		
				public void run() {
					outer_PSyncSegmentPublisher.storage_.remove(segmentName);
				}
			}
		/// <summary>
		/// Create a PSyncSegmentPublisher.
		/// </summary>
		///
		/// <param name="face">The application's Face.</param>
		/// <param name="keyChain">The KeyChain for signing Data packets.</param>
		/// <param name="inMemoryStorageLimit">The limit for the in-memory storage.</param>
		public PSyncSegmentPublisher(Face face, KeyChain keyChain,
				int inMemoryStorageLimit) {
			face_ = face;
			keyChain_ = keyChain;
			// Until InMemoryStorageFifo : an eviction policy, use InMemoryStorageRetaining.
			storage_ = new InMemoryStorageRetaining();
		}
	
		/// <summary>
		/// Create a PSyncSegmentPublisher where inMemoryStorageLimit is
		/// MAX_SEGMENTS_STORED.
		/// </summary>
		///
		/// <param name="face">The application's Face.</param>
		/// <param name="keyChain">The KeyChain for signing Data packets.</param>
		public PSyncSegmentPublisher(Face face, KeyChain keyChain) {
			face_ = face;
			keyChain_ = keyChain;
			// Until InMemoryStorageFifo : an eviction policy, use InMemoryStorageRetaining.
			storage_ = new InMemoryStorageRetaining();
		}
	
		/// <summary>
		/// Put all the segments in the memory store.
		/// </summary>
		///
		/// <param name="interestName"></param>
		/// <param name="dataName">The Data name, which has components after the Interest name.</param>
		/// <param name="content">The content of the data to be segmented.</param>
		/// <param name="freshnessPeriod">The freshness period of the segments, in milliseconds.</param>
		/// <param name="signingInfo">The SigningInfo for signing segment Data packets.</param>
		public void publish(Name interestName, Name dataName, Blob content,
				double freshnessPeriod, SigningInfo signingInfo) {
			long interestSegment = 0;
			if (interestName.get(-1).isSegment())
				interestSegment = interestName.get(-1).toSegment();
	
			ByteBuffer rawBuffer = content.buf().slice();
			int iSegmentBegin = 0;
			int iEnd = content.size();
	
			int maxPacketSize = net.named_data.jndn.util.Common.MAX_NDN_PACKET_SIZE / 2;
	
			long totalSegments = content.size() / maxPacketSize;
			Name.Component finalBlockId = net.named_data.jndn.Name.Component.fromSegment(totalSegments);
	
			Name segmentPrefix = new Name(dataName);
			segmentPrefix.appendVersion((long) net.named_data.jndn.util.Common.getNowMilliseconds());
	
			long segmentNo = 0;
			do {
				int iSegmentEnd = iSegmentBegin + maxPacketSize;
				if (iSegmentEnd > iEnd)
					iSegmentEnd = iEnd;
	
				Name segmentName_0 = new Name(segmentPrefix);
				segmentName_0.appendSegment(segmentNo);
	
				Data data = new Data(segmentName_0);
				// Set the position in the rawBuffer and tell Blob to make a copy.
				rawBuffer.limit(iSegmentEnd);
				rawBuffer.position(iSegmentBegin);
				data.setContent(new Blob(rawBuffer, true));
	
				data.getMetaInfo().setFreshnessPeriod(freshnessPeriod);
				data.getMetaInfo().setFinalBlockId(finalBlockId);
	
				iSegmentBegin = iSegmentEnd;
	
				keyChain_.sign(data, signingInfo);
	
				// Only send the segment to the Face if it has a pending interest.
				// Otherwise, the segment is unsolicited.
				if (interestSegment == segmentNo)
					face_.putData(data);
	
				/* Until InMemoryStorageFifo : an eviction policy, use InMemoryStorageRetaining.
				      storage_.insert(*data, freshnessPeriod);
				*/
				storage_.insert(data);
	
				face_.callLater(freshnessPeriod, new PSyncSegmentPublisher.Anonymous_C0 (this, segmentName_0));
	
				++segmentNo;
			} while (iSegmentBegin < iEnd);
		}
	
		/// <summary>
		/// Put all the segments in the memory store, where signingInfo is the default
		/// SigningInfo().
		/// </summary>
		///
		/// <param name="interestName"></param>
		/// <param name="dataName">The Data name, which has components after the Interest name.</param>
		/// <param name="content">The content of the data to be segmented.</param>
		/// <param name="freshnessPeriod">The freshness period of the segments, in milliseconds.</param>
		public void publish(Name interestName, Name dataName, Blob content,
				double freshnessPeriod) {
			publish(interestName, dataName, content, freshnessPeriod,
					new SigningInfo());
		}
	
		/// <summary>
		/// Try to reply to the Interest name from the memory store.
		/// </summary>
		///
		/// <param name="interestName">The Interest name for looking up in the memory store.</param>
		/// <returns>True if sent the segment Data packet to the Face, or false if we
		/// cannot find the segment, in which case the caller is expected to publish
		/// the segment.</returns>
		public bool replyFromStore(Name interestName) {
			Data data = storage_.find(new Interest(interestName));
	
			if (data != null) {
				face_.putData(data);
				return true;
			}
	
			return false;
		}
	
		public const int MAX_SEGMENTS_STORED = 100;
	
		private readonly Face face_;
		private readonly KeyChain keyChain_;
		/* Until InMemoryStorageFifo : an eviction policy, use InMemoryStorageRetaining.
		  private final InMemoryStorageFifo storage_ = new InMemoryStorageFifo();
		*/
		internal readonly InMemoryStorageRetaining storage_;
	}
}
