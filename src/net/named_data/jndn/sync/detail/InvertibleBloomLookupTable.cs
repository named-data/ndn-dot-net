// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.sync.detail {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.IO.Zip;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// InvertibleBloomLookupTable implements an Invertible Bloom Lookup Table (IBLT)
	/// (Invertible Bloom Filter). This is used by FullPSync2017.
	/// </summary>
	///
	public class InvertibleBloomLookupTable {
		/// <summary>
		/// Create an InvertibleBloomLookupTable.
		/// </summary>
		///
		/// <param name="expectedNEntries">the expected number of entries in the IBLT.</param>
		public InvertibleBloomLookupTable(int expectedNEntries) {
			// 1.5 times the expected number of entries gives a very low probability of
			// a decoding failure.
			int nEntries = expectedNEntries + expectedNEntries / 2;
			// Make nEntries exactly divisible by N_HASH.
			int remainder = nEntries % N_HASH;
			if (remainder != 0)
				nEntries += (N_HASH - remainder);
	
			hashTable_ = new ArrayList<HashTableEntry>(nEntries);
			for (int i = 0; i < nEntries; ++i)
				ILOG.J2CsMapping.Collections.Collections.Add(hashTable_,new InvertibleBloomLookupTable.HashTableEntry ());
		}
	
		/// <summary>
		/// Create an InvertibleBloomLookupTable of the given iblt.
		/// </summary>
		///
		/// <param name="iblt">The InvertibleBloomLookupTable to copy.</param>
		public InvertibleBloomLookupTable(InvertibleBloomLookupTable iblt) {
			// Make a deep copy the hashTable_ array.
			hashTable_ = new ArrayList<HashTableEntry>(iblt.hashTable_.Count);
			for (int i = 0; i < iblt.hashTable_.Count; ++i)
				ILOG.J2CsMapping.Collections.Collections.Add(hashTable_,new InvertibleBloomLookupTable.HashTableEntry (iblt.hashTable_[i]));
		}
	
		/// <summary>
		/// Populate the hash table using the encoded array representation of the IBLT.
		/// </summary>
		///
		/// <param name="encoding">The encoded representation of the IBLT.</param>
		/// <exception cref="System.AssertionError">if the size of the decoded values is not compatiblewith this IBLT.</exception>
		public void initialize(Blob encoding) {
			long[] values = decode(encoding);
	
			if (3 * hashTable_.Count != values.Length)
				throw new AssertionError(
						"The received Invertible Bloom Filter cannot be decoded");
	
			for (int i = 0; i < hashTable_.Count; i++) {
				InvertibleBloomLookupTable.HashTableEntry  entry = hashTable_[i];
				if (values[i * 3] != 0) {
					entry.count_ = (int) (values[i * 3]);
					entry.keySum_ = values[(i * 3) + 1];
					entry.keyCheck_ = values[(i * 3) + 2];
				}
			}
		}
	
		public void insert(long key) {
			update(INSERT, key);
		}
	
		public void erase(long key) {
			update(ERASE, key);
		}
	
		/// <summary>
		/// List all the entries in the IBLT.
		/// This is called on a difference of two IBLTs: ownIBLT - receivedIBLT.
		/// Entries listed in positive are in ownIBLT but not in receivedIBLT.
		/// Entries listed in negative are in receivedIBLT but not in ownIBLT.
		/// </summary>
		///
		/// <param name="positive">Add positive entries to this set. This first clears the set.</param>
		/// <param name="negative">Add negative entries to this set. This first clears the set.</param>
		/// <returns>True if decoding is completed successfully.</returns>
		public bool listEntries(HashedSet<Int64> positive,
				HashedSet<Int64> negative) {
			ILOG.J2CsMapping.Collections.Collections.Clear(positive);
			ILOG.J2CsMapping.Collections.Collections.Clear(negative);
	
			// Make a deep copy.
			InvertibleBloomLookupTable peeled = new InvertibleBloomLookupTable(this);
	
			int nErased = 0;
			do {
				nErased = 0;
				/* foreach */
				foreach (InvertibleBloomLookupTable.HashTableEntry  entry  in  peeled.hashTable_) {
					if (entry.isPure()) {
						if (entry.count_ == 1)
							ILOG.J2CsMapping.Collections.Collections.Add(positive,entry.keySum_);
						else
							ILOG.J2CsMapping.Collections.Collections.Add(negative,entry.keySum_);
	
						peeled.update(-entry.count_, entry.keySum_);
						++nErased;
					}
				}
			} while (nErased > 0);
	
			/* foreach */
			// If any buckets foreach one of the hash functions is not empty, then we didn't
			// peel them all.
			foreach (InvertibleBloomLookupTable.HashTableEntry  entry_0  in  peeled.hashTable_) {
				if (!entry_0.isEmpty())
					return false;
			}
	
			return true;
		}
	
		/// <summary>
		/// Get a new IBLT which is the difference of the other IBLT from this IBLT.
		/// </summary>
		///
		/// <param name="other">The other IBLT.</param>
		/// <returns>A new IBLT of this - other.</returns>
		public InvertibleBloomLookupTable difference(
				InvertibleBloomLookupTable other) {
			if (hashTable_.Count != other.hashTable_.Count)
				throw new Exception(
						"IBLT difference: Both tables must be the same size");
	
			InvertibleBloomLookupTable result = new InvertibleBloomLookupTable(this);
			for (int i = 0; i < hashTable_.Count; ++i) {
				InvertibleBloomLookupTable.HashTableEntry  e1 = result.hashTable_[i];
				InvertibleBloomLookupTable.HashTableEntry  e2 = other.hashTable_[i];
				e1.count_ -= e2.count_;
				e1.keySum_ ^= e2.keySum_;
				e1.keyCheck_ ^= e2.keyCheck_;
			}
	
			return result;
		}
	
		/// <summary>
		/// Encode this IBLT to a Blob. This encodes this hash table from a uint32_t
		/// array to a uint8_t array. We create a uin8_t array 12 times the size of
		/// the uint32_t array. We put the first count in the first 4 cells, keySum in
		/// the next 4, and keyCheck in the next 4. We repeat for all the other cells
		/// of the hash table. Then we append this uint8_t array to the name.
		/// </summary>
		///
		/// <returns>The encoded Blob.</returns>
		public Blob encode() {
			int nEntries = hashTable_.Count;
			int unitSize = (32 * 3) / 8; // hard coding
			int tableSize = unitSize * nEntries;
	
			byte[] table = new byte[tableSize];
	
			for (int i = 0; i < nEntries; i++) {
				InvertibleBloomLookupTable.HashTableEntry  entry = hashTable_[i];
	
				// table[i*12],   table[i*12+1], table[i*12+2], table[i*12+3] --> hashTable[i].count_
	
				table[(i * unitSize)] = (byte) (0xFF & entry.count_);
				table[(i * unitSize) + 1] = (byte) (0xFF & (entry.count_ >> 8));
				table[(i * unitSize) + 2] = (byte) (0xFF & (entry.count_ >> 16));
				table[(i * unitSize) + 3] = (byte) (0xFF & (entry.count_ >> 24));
	
				// table[i*12+4], table[i*12+5], table[i*12+6], table[i*12+7] --> hashTable[i].keySum_
	
				table[(i * unitSize) + 4] = (byte) (0xFF & entry.keySum_);
				table[(i * unitSize) + 5] = (byte) (0xFF & (entry.keySum_ >> 8));
				table[(i * unitSize) + 6] = (byte) (0xFF & (entry.keySum_ >> 16));
				table[(i * unitSize) + 7] = (byte) (0xFF & (entry.keySum_ >> 24));
	
				// table[i*12+8], table[i*12+9], table[i*12+10], table[i*12+11] --> hashTable[i].keyCheck_
	
				table[(i * unitSize) + 8] = (byte) (0xFF & entry.keyCheck_);
				table[(i * unitSize) + 9] = (byte) (0xFF & (entry.keyCheck_ >> 8));
				table[(i * unitSize) + 10] = (byte) (0xFF & (entry.keyCheck_ >> 16));
				table[(i * unitSize) + 11] = (byte) (0xFF & (entry.keyCheck_ >> 24));
			}
	
			MemoryStream outputStream = new MemoryStream();
			int compressionLevel = 9;
			DeflaterOutputStream deflaterStream = new DeflaterOutputStream(
					outputStream, new Deflater(compressionLevel));
	
			// Use "try/finally instead of "try-with-resources" or "using"
			// which are not supported before Java 7.
			try {
				deflaterStream.Write(table,0,table.Length);
				deflaterStream.flush();
			} finally {
				deflaterStream.close();
			}
	
			return new Blob(outputStream.ToArray(), false);
		}
	
		/// <summary>
		/// Check if this IBLT has the same number of entries as the other IBLT and
		/// that they are equal.
		/// </summary>
		///
		/// <param name="other">The other OBLT to check.</param>
		/// <returns>true if this IBLT is equal to the other, otherwise false.</returns>
		public bool equals(InvertibleBloomLookupTable other) {
			ArrayList<HashTableEntry> iblt1HashTable = hashTable_;
			ArrayList<HashTableEntry> iblt2HashTable = other.hashTable_;
			if (iblt1HashTable.Count != iblt2HashTable.Count)
				return false;
	
			for (int i = 0; i < iblt1HashTable.Count; i++) {
				if (iblt1HashTable[i].count_ != iblt2HashTable[i].count_
						|| iblt1HashTable[i].keySum_ != iblt2HashTable[i].keySum_
						|| iblt1HashTable[i].keyCheck_ != iblt2HashTable[i].keyCheck_)
					return false;
			}
	
			return true;
		}
	
		public const int N_HASH = 3;
		public const int N_HASHCHECK = 11;
	
		private class HashTableEntry {
			/// <summary>
			/// The default constructor.
			/// </summary>
			///
			public HashTableEntry() {
			}
	
			/// <summary>
			/// The copy constructor.
			/// </summary>
			///
			public HashTableEntry(InvertibleBloomLookupTable.HashTableEntry  entry) {
				count_ = entry.count_;
				keySum_ = entry.keySum_;
				keyCheck_ = entry.keyCheck_;
			}
	
			public bool isPure() {
				if (count_ == 1 || count_ == -1) {
					long check = Common.MurmurHash3(net.named_data.jndn.sync.detail.InvertibleBloomLookupTable.N_HASHCHECK, keySum_);
					return keyCheck_ == check;
				}
	
				return false;
			}
	
			public bool isEmpty() {
				return count_ == 0 && keySum_ == 0 && keyCheck_ == 0;
			}
	
			public int count_ = 0;
			public long keySum_ = 0;
			public long keyCheck_ = 0;
		}
	
		/// <summary>
		/// Update the entries in hashTable_.
		/// </summary>
		///
		/// <param name="plusOrMinus">The amount to update the count.</param>
		/// <param name="key">The key for computing the entry.</param>
		private void update(int plusOrMinus, long key) {
			int bucketsPerHash = hashTable_.Count / N_HASH;
	
			for (int i = 0; i < N_HASH; i++) {
				int startEntry = i * bucketsPerHash;
				long h = Common.MurmurHash3(i, key);
				InvertibleBloomLookupTable.HashTableEntry  entry = hashTable_[startEntry
									+ (int) (h % bucketsPerHash)];
				entry.count_ += plusOrMinus;
				entry.keySum_ ^= key;
				entry.keyCheck_ ^= Common.MurmurHash3(N_HASHCHECK, key);
			}
		}
	
		/// <summary>
		/// Decode the IBLT from the Blob. This converts the Blob into a byte array
		/// which is then decoded to a long array.
		/// </summary>
		///
		/// <param name="encoding">The encoded IBLT.</param>
		/// <returns>An int array representing the hash table of the IBLT.</returns>
		private static long[] decode(Blob encoding) {
			InflaterInputStream inflaterStream = new InflaterInputStream(
					new MemoryStream(encoding.getImmutableArray()));
			MemoryStream outputStream = new MemoryStream();
			byte[] buffer = new byte[encoding.size()];
	
			while (true) {
				int count = inflaterStream.Read(buffer,0,buffer.Length);
				if (count <= 0)
					break;
	
				outputStream.write(buffer, 0, count);
			}
	
			byte[] ibltValues = outputStream.ToArray();
	
			int nEntries = ibltValues.Length / 4;
			long[] values = new long[nEntries];
	
			for (int i = 0; i < 4 * nEntries; i += 4) {
				// Temporarily use a long for an unsigned 32-bit integer.
				long t = (((long) ibltValues[i + 3] & 0xff) << 24)
						+ (((long) ibltValues[i + 2] & 0xff) << 16)
						+ (((long) ibltValues[i + 1] & 0xff) << 8)
						+ ((long) ibltValues[i] & 0xff);
				values[i / 4] = t;
			}
	
			return values;
		}
	
		private readonly ArrayList<HashTableEntry> hashTable_;
	
		private const int INSERT = 1;
		private const int ERASE = -1;
	}
}
