// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.sync.detail {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// PSyncUserPrefixes holds the prefixes_ map from prefix to sequence number,
	/// used by PSyncPartialProducer and FullPSync2017WithUsers.
	/// </summary>
	///
	public class PSyncUserPrefixes {
		public PSyncUserPrefixes() {
			this.prefixes_ = new Hashtable<Name, Object>();
		}
	
		/// <summary>
		/// Check if the prefix is in prefixes_.
		/// </summary>
		///
		/// <param name="prefix">The prefix to check.</param>
		/// <returns>True if the prefix is in prefixes_.</returns>
		public bool isUserNode(Name prefix) {
			return prefixes_.Contains(prefix);
		}
	
		/// <summary>
		/// Return the current sequence number of the given prefix.
		/// </summary>
		///
		/// <param name="prefix">The prefix for the sequence number.</param>
		/// <returns>The sequence number for the prefix, or -1 if not found.</returns>
		public int getSequenceNo(Name prefix) {
			Object sequenceNo = ILOG.J2CsMapping.Collections.Collections.Get(prefixes_,prefix);
			if (sequenceNo == null)
				return -1;
	
			return (int) sequenceNo;
		}
	
		/// <summary>
		/// Return the current sequence number of the given prefix, or zero if not found.
		/// </summary>
		///
		/// <param name="prefix">The prefix for the sequence number.</param>
		/// <returns>The sequence number for the prefix, or 0 if not found.</returns>
		public int getSequenceNoOrZero(Name prefix) {
			Object sequenceNo = ILOG.J2CsMapping.Collections.Collections.Get(prefixes_,prefix);
			if (sequenceNo == null)
				return 0;
	
			return (int) sequenceNo;
		}
	
		/// <summary>
		/// Add a user node for synchronization based on the prefix Name, and
		/// initialize the sequence number to zero. However, if the prefix Name already
		/// exists, then do nothing and return false. This does not add sequence number
		/// zero to the IBLT because, if a large number of user nodes are added, then
		/// decoding the difference between our own IBLT and the other IBLT will not be
		/// possible.
		/// </summary>
		///
		/// <param name="prefix">The prefix Name of the user node to be added.</param>
		/// <returns>True if the user node with the prefix Name was added, false if the
		/// prefix Name already exists.</returns>
		public bool addUserNode(Name prefix) {
			if (!isUserNode(prefix)) {
				ILOG.J2CsMapping.Collections.Collections.Put(prefixes_,prefix,0);
				return true;
			} else
				return false;
		}
	
		/// <summary>
		/// Remove the user node from synchronization. If the prefix is not in
		/// prefixes_, then do nothing.
		/// The caller should first check isUserNode(prefix) and erase the prefix from
		/// the IBLT and other maps if needed.
		/// </summary>
		///
		/// <param name="prefix">The prefix Name of the user node to be removed.</param>
		public void removeUserNode(Name prefix) {
			ILOG.J2CsMapping.Collections.Collections.Remove(prefixes_,prefix);
		}
	
		/// <summary>
		/// Update prefixes_ with the given prefix and sequence number. This does not
		/// update the IBLT. This logs a message for the update.
		/// Whoever calls this needs to make sure that isUserNode(prefix) is true.
		/// </summary>
		///
		/// <param name="prefix">The prefix of the update.</param>
		/// <param name="sequenceNo">The sequence number of the update.</param>
		/// <param name="oldSequenceNo">zero, the caller can remove the old prefix from the IBLT.</param>
		/// <returns>True if the sequence number was updated, false if the prefix was
		/// not in prefixes_, or if the sequenceNo is less than or equal to the old
		/// sequence number. If this returns false, the caller should not update the
		/// IBLT.</returns>
		public bool updateSequenceNo(Name prefix, int sequenceNo,
				int[] oldSequenceNo) {
			oldSequenceNo[0] = 0;
			logger_.log(ILOG.J2CsMapping.Util.Logging.Level.FINE, "updateSequenceNo: {0} " + sequenceNo, prefix);
	
			Object entrySequenceNo = ILOG.J2CsMapping.Collections.Collections.Get(prefixes_,prefix);
			if (entrySequenceNo != null)
				oldSequenceNo[0] = (int) entrySequenceNo;
			else {
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.INFO, "The prefix was not found in prefixes_");
				return false;
			}
	
			if (oldSequenceNo[0] >= sequenceNo) {
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.INFO,
						"The update has a lower/equal sequence number for the prefix. Doing nothing!");
				return false;
			}
	
			// Insert the new sequence number.
			ILOG.J2CsMapping.Collections.Collections.Put(prefixes_,prefix,sequenceNo);
			return true;
		}
	
		// The key is the prefix Name. The value is the sequence number for the prefix.
		public readonly Hashtable<Name, Object> prefixes_;
		private static readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(PSyncUserPrefixes).FullName);
		// This is to force an import of net.named_data.jndn.util.
		private static Common dummyCommon_ = new Common();
	}
}
