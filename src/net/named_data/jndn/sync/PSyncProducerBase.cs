// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.sync {
	
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.sync.detail;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// PSyncProducerBase is a base class for PsyncPartialProducer and FullPSync2017.
	/// </summary>
	///
	public class PSyncProducerBase {
		/// <summary>
		/// Create a PSyncProducerBase.
		/// </summary>
		///
		/// <param name="expectedNEntries">The expected number of entries in the IBLT.</param>
		/// <param name="syncPrefix">The prefix Name of the sync group, which is copied.</param>
		/// <param name="syncReplyFreshnessPeriod"></param>
		protected internal PSyncProducerBase(int expectedNEntries, Name syncPrefix,
				double syncReplyFreshnessPeriod) {
			iblt_ = new InvertibleBloomLookupTable(expectedNEntries);
			expectedNEntries_ = expectedNEntries;
			threshold_ = expectedNEntries / 2;
			syncPrefix_ = new Name(syncPrefix);
			syncReplyFreshnessPeriod_ = syncReplyFreshnessPeriod;
		}
	
		/// <summary>
		/// Insert the URI of the name into the iblt_, and update nameToHash_ and
		/// hashToName_.
		/// </summary>
		///
		/// <param name="name">The Name to insert.</param>
		protected internal void insertIntoIblt(Name name) {
			String uri = name.toUri();
			long newHash = Common.MurmurHash3(
					net.named_data.jndn.sync.detail.InvertibleBloomLookupTable.N_HASHCHECK,
					new Blob(uri).getImmutableArray());
			ILOG.J2CsMapping.Collections.Collections.Put(nameToHash_,name,newHash);
			ILOG.J2CsMapping.Collections.Collections.Put(hashToName_,newHash,name);
			iblt_.insert(newHash);
		}
	
		/// <summary>
		/// If the Name is in nameToHash_, then remove the hash from the iblt_,
		/// nameToHash_ and hashToName_. However, if the Name is not in nameToHash_
		/// then do nothing.
		/// </summary>
		///
		/// <param name="name">The Name to remove.</param>
		protected internal void removeFromIblt(Name name) {
			Object hash = ILOG.J2CsMapping.Collections.Collections.Get(nameToHash_,name);
			if (hash != null) {
				ILOG.J2CsMapping.Collections.Collections.Remove(nameToHash_,name);
				ILOG.J2CsMapping.Collections.Collections.Remove(hashToName_,hash);
				iblt_.erase((long) hash);
			}
		}
	
		/// <summary>
		/// This is called when registerPrefix fails to log an error message.
		/// </summary>
		///
		public static void onRegisterFailed(Name prefix) {
			logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE,
					"PSyncProduerBase: Failed to register prefix: {0}", prefix);
		}
	
		protected internal readonly InvertibleBloomLookupTable iblt_;
		protected internal readonly int expectedNEntries_;
		// threshold_ is used to check if an IBLT difference is greater than the
		// threshold, and whether we need to update the other IBLT.
		protected internal readonly int threshold_;
	
		// nameToHash_ and hashToName_ are just for looking up the hash more quickly
		// (instead of calculating it again).
		// The key is the Name. The value is the hash.
		protected internal readonly Hashtable<Name, Object> nameToHash_ = new Hashtable<Name, Object>();
		// The key is the hash. The value is the Name.
		protected internal readonly Hashtable<Object, Name> hashToName_ = new Hashtable<Object, Name>();
	
		protected internal readonly Name syncPrefix_;
		protected internal readonly double syncReplyFreshnessPeriod_;
		private static readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(PSyncProducerBase).FullName);
	}
}
