// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.sync {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Util.Logging;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.security;
	using net.named_data.jndn.sync.detail;
	using net.named_data.jndn.util;
	
	/// <summary>
	/// FullPSync2017WithUsers uses FullPSync2017 to implement the full sync logic of
	/// PSync to synchronize with other nodes, where all nodes want to sync the
	/// sequence number of all users based on their user prefix. The application
	/// should call publishName whenever it wants to let consumers know that new data
	/// with a new sequence number is available for the user prefix. Multiple user
	/// prefixes can be added by using addUserNode. Currently, fetching and
	/// publishing the data (named by the user prefix plus the sequence number) needs
	/// to be handled by the application. See FullPSync2017 for details on the
	/// Full PSync protocol. The Full PSync
	/// protocol is described in Section G "Full-Data Synchronization" of:
	/// https://named-data.net/wp-content/uploads/2017/05/scalable_name-based_data_synchronization.pdf
	/// (Note: In the PSync library, this class is called FullProducer. But because
	/// the class actually handles both producing and consuming, we omit "producer"
	/// in the name to avoid confusion.)
	/// </summary>
	///
	public class FullPSync2017WithUsers : FullPSync2017.OnNamesUpdate,
			FullPSync2017.CanAddToSyncData, FullPSync2017.CanAddReceivedName {
		public interface OnUpdate {
			void onUpdate(ArrayList<PSyncMissingDataInfo> updates);
		}
	
		/// <summary>
		/// Create a FullPSync2017WithUsers.
		/// </summary>
		///
		/// <param name="expectedNEntries">The expected number of entries in the IBLT.</param>
		/// <param name="face">The application's Face.</param>
		/// <param name="syncPrefix">The prefix Name of the sync group, which is copied.</param>
		/// <param name="userPrefix">addUserNode.</param>
		/// <param name="onUpdate">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="keyChain">The KeyChain for signing Data packets.</param>
		/// <param name="syncInterestLifetime"></param>
		/// <param name="syncReplyFreshnessPeriod"></param>
		/// <param name="signingInfo"></param>
		public FullPSync2017WithUsers(int expectedNEntries, Face face,
				Name syncPrefix, Name userPrefix, FullPSync2017WithUsers.OnUpdate  onUpdate,
				KeyChain keyChain, double syncInterestLifetime,
				double syncReplyFreshnessPeriod, SigningInfo signingInfo) {
			this.prefixes_ = new PSyncUserPrefixes();
			onUpdate_ = onUpdate;
			fullPSync_ = new FullPSync2017(expectedNEntries, face, syncPrefix,
					this, keyChain, syncInterestLifetime, syncReplyFreshnessPeriod,
					signingInfo, this, this);
	
			if (userPrefix != null && userPrefix.size() > 0)
				addUserNode(userPrefix);
		}
	
		/// <summary>
		/// Create a FullPSync2017WithUsers, where signingInfo is the default
		/// SigningInfo().
		/// </summary>
		///
		/// <param name="expectedNEntries">The expected number of entries in the IBLT.</param>
		/// <param name="face">The application's Face.</param>
		/// <param name="syncPrefix">The prefix Name of the sync group, which is copied.</param>
		/// <param name="userPrefix">addUserNode.</param>
		/// <param name="onUpdate">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="keyChain">The KeyChain for signing Data packets.</param>
		/// <param name="syncInterestLifetime"></param>
		/// <param name="syncReplyFreshnessPeriod"></param>
		public FullPSync2017WithUsers(int expectedNEntries, Face face,
				Name syncPrefix, Name userPrefix, FullPSync2017WithUsers.OnUpdate  onUpdate,
				KeyChain keyChain, double syncInterestLifetime,
				double syncReplyFreshnessPeriod) {
			this.prefixes_ = new PSyncUserPrefixes();
			onUpdate_ = onUpdate;
			fullPSync_ = new FullPSync2017(expectedNEntries, face, syncPrefix,
					this, keyChain, syncInterestLifetime, syncReplyFreshnessPeriod,
					new SigningInfo(), this, this);
	
			if (userPrefix != null && userPrefix.size() > 0)
				addUserNode(userPrefix);
		}
	
		/// <summary>
		/// Create a FullPSync2017WithUsers, where syncInterestLifetime is
		/// FullPSync2017.DEFAULT_SYNC_INTEREST_LIFETIME, syncReplyFreshnessPeriod is
		/// FullPSync2017.DEFAULT_SYNC_REPLY_FRESHNESS_PERIOD, and signingInfo is the
		/// default SigningInfo().
		/// </summary>
		///
		/// <param name="expectedNEntries">The expected number of entries in the IBLT.</param>
		/// <param name="face">The application's Face.</param>
		/// <param name="syncPrefix">The prefix Name of the sync group, which is copied.</param>
		/// <param name="userPrefix">addUserNode.</param>
		/// <param name="onUpdate">NOTE: The library will log any exceptions thrown by this callback, but for better error handling the callback should catch and properly handle any exceptions.</param>
		/// <param name="keyChain">The KeyChain for signing Data packets.</param>
		public FullPSync2017WithUsers(int expectedNEntries, Face face,
				Name syncPrefix, Name userPrefix, FullPSync2017WithUsers.OnUpdate  onUpdate,
				KeyChain keyChain) {
			this.prefixes_ = new PSyncUserPrefixes();
			onUpdate_ = onUpdate;
			fullPSync_ = new FullPSync2017(expectedNEntries, face, syncPrefix,
					this, keyChain, net.named_data.jndn.sync.FullPSync2017.DEFAULT_SYNC_INTEREST_LIFETIME,
					net.named_data.jndn.sync.FullPSync2017.DEFAULT_SYNC_REPLY_FRESHNESS_PERIOD,
					new SigningInfo(), this, this);
	
			if (userPrefix != null && userPrefix.size() > 0)
				addUserNode(userPrefix);
		}
	
		/// <summary>
		/// Return the current sequence number of the given user prefix.
		/// </summary>
		///
		/// <param name="prefix">The user prefix for the sequence number.</param>
		/// <returns>The sequence number for the user prefix, or -1 if not found.</returns>
		public int getSequenceNo(Name prefix) {
			return prefixes_.getSequenceNo(prefix);
		}
	
		/// <summary>
		/// Add a user node for synchronization based on the prefix Name, and
		/// initialize the sequence number to zero. However, if the prefix Name already
		/// exists, then do nothing and return false. This does not add sequence number
		/// zero to the IBLT because, if a large number of user nodes are added, then
		/// decoding the difference between our own IBLT and the other IBLT will not be
		/// possible.
		/// </summary>
		///
		/// <param name="prefix">The prefix Name of the user node to be added.</param>
		/// <returns>True if the user node with the prefix Name was added, false if the
		/// prefix Name already exists.</returns>
		public bool addUserNode(Name prefix) {
			return prefixes_.addUserNode(prefix);
		}
	
		/// <summary>
		/// Remove the user node from the synchronization. This erases the prefix from
		/// the IBLT and other tables.
		/// </summary>
		///
		/// <param name="prefix"></param>
		public void removeUserNode(Name prefix) {
			if (prefixes_.isUserNode(prefix)) {
				int sequenceNo = (int) ILOG.J2CsMapping.Collections.Collections.Get(prefixes_.prefixes_,prefix);
				prefixes_.removeUserNode(prefix);
				fullPSync_.removeName(new Name(prefix).appendNumber(sequenceNo));
			}
		}
	
		/// <summary>
		/// Publish the sequence number for the prefix Name to inform the others.
		/// (addUserNode needs to be called before this to add the prefix, if it was
		/// not already added via the constructor.)
		/// </summary>
		///
		/// <param name="prefix">the prefix Name to be updated.</param>
		/// <param name="sequenceNo">number is incremented by 1.</param>
		public void publishName(Name prefix, int sequenceNo) {
			if (!prefixes_.isUserNode(prefix)) {
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.WARNING, "Prefix not added: {0}" + prefix);
				return;
			}
	
			int newSequenceNo = (sequenceNo >= 0) ? sequenceNo : prefixes_
					.getSequenceNoOrZero(prefix) + 1;
	
			logger_.log(ILOG.J2CsMapping.Util.Logging.Level.INFO, "Publish: " + prefix.toUri() + "/"
					+ newSequenceNo);
			if (updateSequenceNo(prefix, newSequenceNo))
				// Insert the new sequence number.
				fullPSync_
						.publishName(new Name(prefix).appendNumber(newSequenceNo));
		}
	
		/// <summary>
		/// Publish the sequence number for the prefix Name to inform the others, where
		/// the existing sequence number is incremented by 1.
		/// (addUserNode needs to be called before this to add the prefix, if it was
		/// not already added via the constructor.)
		/// </summary>
		///
		/// <param name="prefix">the prefix Name to be updated.</param>
		public void publishName(Name prefix) {
			publishName(prefix, -1);
		}
	
		/// <summary>
		/// This is called when new names are received to check if the name can be
		/// added to the IBLT.
		/// </summary>
		///
		/// <param name="name">The Name to check.</param>
		/// <returns>True if the received name can be added.</returns>
		public bool canAddReceivedName(Name name) {
			Name prefix = name.getPrefix(-1);
			long sequenceNo = name.get(-1).toNumber();
	
			bool havePrefix = prefixes_.isUserNode(prefix);
			if (!havePrefix || (int) ILOG.J2CsMapping.Collections.Collections.Get(prefixes_.prefixes_,prefix) < sequenceNo) {
				if (havePrefix) {
					int oldSequenceNo = prefixes_.getSequenceNoOrZero(prefix);
					if (oldSequenceNo != 0)
						// Remove the old sequence number from the IBLT before the caller adds
						// the new one.
						fullPSync_.removeName(new Name(prefix)
								.appendNumber(oldSequenceNo));
				}
	
				return true;
			} else
				return false;
		}
	
		/// <summary>
		/// This is called when new names are received. Update prefixes_, create the
		/// list of PSyncMissingDataInfo and call the onUpdate_ callback.
		/// </summary>
		///
		/// <param name="names">The new received names.</param>
		public void onNamesUpdate(ArrayList<Name> names) {
			ArrayList<PSyncMissingDataInfo> updates = new ArrayList<PSyncMissingDataInfo>();
	
			/* foreach */
			foreach (Name name  in  names) {
				Name prefix = name.getPrefix(-1);
				long sequenceNo = name.get(-1).toNumber();
	
				ILOG.J2CsMapping.Collections.Collections.Add(updates,new PSyncMissingDataInfo(prefix, prefixes_
									.getSequenceNoOrZero(prefix) + 1, (int) sequenceNo));
	
				// canAddReceivedName already made sure that the new sequenceNo is greater
				// than the old one, and removed the old one from the IBLT.
				ILOG.J2CsMapping.Collections.Collections.Put(prefixes_.prefixes_,prefix,(int) sequenceNo);
			}
	
			try {
				onUpdate_.onUpdate(updates);
			} catch (Exception ex) {
				logger_.log(ILOG.J2CsMapping.Util.Logging.Level.SEVERE, "Error in onUpdate", ex);
			}
		}
	
		/// <summary>
		/// Get the prefix from the name and check if hash(prefix + 1) is in the
		/// negative set, i.e. "isNotFutureHash" (Sometimes the Interest from the other
		/// side gets to us before the Data.)
		/// </summary>
		///
		/// <returns>True if hash(prefix + 1) is NOT in the negative set (meaning that
		/// it is not a future hash), or false if it IS in the negative set.</returns>
		public bool canAddToSyncData(Name name, HashedSet<Int64> negative) {
			Name prefix = name.getPrefix(-1);
	
			String uri = new Name(prefix).appendNumber(
					prefixes_.getSequenceNoOrZero(prefix) + 1).toUri();
			long nextHash = net.named_data.jndn.util.Common.murmurHash3(
					net.named_data.jndn.sync.detail.InvertibleBloomLookupTable.N_HASHCHECK,
					new Blob(uri).getImmutableArray());
	
			/* foreach */
			foreach (Int64 negativeHash  in  negative) {
				if ((negativeHash) == nextHash)
					return false;
			}
	
			return true;
		}
	
		/// <summary>
		/// Update prefixes_ and iblt_ with the given prefix and sequence number.
		/// Whoever calls this needs to make sure that prefix is in prefixes_.
		/// We remove an already-existing prefix/sequence number from iblt_ (unless
		/// sequenceNo is zero because we don't insert a zero sequence number into the
		/// IBLT.) Then we update prefixes_. If this returns true, the caller should
		/// update  nameToHash_, hashToName_ and iblt_ .
		/// </summary>
		///
		/// <param name="prefix">The prefix of the sequence number to update.</param>
		/// <param name="sequenceNumber">The new sequence number.</param>
		/// <returns>True if the prefixes_ were updated, false if not.</returns>
		private bool updateSequenceNo(Name prefix, int sequenceNo) {
			int[] oldSequenceNo = new int[1];
			if (!prefixes_.updateSequenceNo(prefix, sequenceNo, oldSequenceNo))
				return false;
	
			// Delete the old sequence number from the IBLT. If oldSequenceNo is zero, we
			// don't need to delete it, because we don't insert a prefix with sequence
			// number zero in the IBLT.
			if (oldSequenceNo[0] != 0)
				fullPSync_.removeName(new Name(prefix)
						.appendNumber(oldSequenceNo[0]));
	
			return true;
		}
	
		private readonly FullPSync2017WithUsers.OnUpdate  onUpdate_;
		private readonly FullPSync2017 fullPSync_;
		private readonly PSyncUserPrefixes prefixes_;
		private static readonly Logger logger_ = ILOG.J2CsMapping.Util.Logging.Logger
				.getLogger(typeof(FullPSync2017WithUsers).FullName);
	}
}
