// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2014-2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.tests.unit_tests {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.encoding;
	using net.named_data.jndn.security;
	using net.named_data.jndn.security.identity;
	using net.named_data.jndn.security.policy;
	using net.named_data.jndn.util;
	
	internal class VerifyInterestCounter : OnVerifiedInterest,
			OnInterestValidationFailed {
		public VerifyInterestCounter() {
			this.onVerifiedCallCount_ = 0;
			this.onValidationFailedCallCount_ = 0;
		}
	
		public virtual void onVerifiedInterest(Interest interest) {
			++onVerifiedCallCount_;
		}
	
		public virtual void onInterestValidationFailed(Interest interest, String reason) {
			++onValidationFailedCallCount_;
		}
	
		public int onVerifiedCallCount_;
		public int onValidationFailedCallCount_;
	} 
	
	public class TestInterestMethods {
		// Convert the int array to a ByteBuffer.
		private static ByteBuffer toBuffer(int[] array) {
			ByteBuffer result = ILOG.J2CsMapping.NIO.ByteBuffer.allocate(array.Length);
			for (int i = 0; i < array.Length; ++i)
				result.put((byte) (array[i] & 0xff));
	
			result.flip();
			return result;
		}
	
		private static readonly ByteBuffer codedInterest = toBuffer(new int[] {
				0x05,
				0x5C, // Interest
				0x07, 0x0A, 0x08, 0x03, 0x6E,
				0x64,
				0x6E,
				0x08,
				0x03,
				0x61,
				0x62,
				0x63, // Name
				0x09,
				0x38, // Selectors
				0x0D,
				0x01,
				0x04, // MinSuffixComponents
				0x0E,
				0x01,
				0x06, // MaxSuffixComponents
				0x0F,
				0x22, // KeyLocator
				0x1D,
				0x20, // KeyLocatorDigest
				0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
				0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
				0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x10,
				0x07, // Exclude
				0x08, 0x03, 0x61, 0x62, 0x63, // NameComponent
				0x13, 0x00, // Any
				0x11, 0x01, 0x01, // ChildSelector
				0x12, 0x00, // MustBeFesh
				0x0A, 0x04, 0x61, 0x62, 0x61, 0x62, // Nonce
				0x0C, 0x02, 0x75, 0x30, // InterestLifetime
				0x1e, 0x0a, // ForwardingHint
				0x1f, 0x08, // Delegation
				0x1e, 0x01, 0x01, // Preference=1
				0x07, 0x03, 0x08, 0x01, 0x41, // Name=/A
				1 });
	
		private static readonly ByteBuffer codedInterestNoSelectors = toBuffer(new int[] {
				0x05,
				0x12, // Interest
				0x07, 0x0A, 0x08, 0x03, 0x6E, 0x64, 0x6E, 0x08, 0x03, 0x61, 0x62,
				0x63, // Name
				0x0A, 0x04, 0x61, 0x62, 0x61, 0x62 // Nonce
		});
	
		static internal String dump(Object s1) {
			return "" + s1;
		}
	
		static internal String dump(Object s1, Object s2) {
			return s1 + " " + s2;
		}
	
		private static readonly ArrayList initialDump = new ArrayList(
				ILOG.J2CsMapping.Collections.Arrays.AsList(new Object[] {
									"name: /ndn/abc",
									"minSuffixComponents: 4",
									"maxSuffixComponents: 6",
									"keyLocator: KeyLocatorDigest: 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f",
									"exclude: abc,*", "childSelector: 1", "mustBeFresh: true",
									"nonce: 61626162", "lifetimeMilliseconds: 30000",
									"forwardingHint:", "  Preference: 1, Name: /A" }));
	
		private static readonly ByteBuffer simpleCodedInterestV03 = toBuffer(new int[] {
				0x05, 0x07, // Interest
				0x07, 0x03, 0x08, 0x01, 0x49, // Name = /I
				0x12, 0x00, // MustBeFresh
		});
	
		private static readonly ArrayList simpleCodedInterestV03Dump = new ArrayList(
				ILOG.J2CsMapping.Collections.Arrays.AsList(new Object[] { "name: /I",
									"minSuffixComponents: <none>", "maxSuffixComponents: 1",
									"keyLocator: <none>", "exclude: <none>",
									"childSelector: <none>", "mustBeFresh: true",
									"nonce: <none>", "lifetimeMilliseconds: <none>",
									"forwardingHint: <none>" }));
	
		private static readonly ByteBuffer fullCodedInterestV03 = toBuffer(new int[] {
				0x05, 0x29, // Interest
				0x07, 0x03, 0x08, 0x01, 0x49, // Name = /I
				0x21, 0x00, // CanBePrefix
				0x12, 0x00, // MustBeFresh
				0x1E, 0x0B, // ForwardingHint
				0x1F, 0x09, // Delegation
				0x1E, 0x02, 0x01, 0x00, // Preference = 256
				0x07, 0x03, 0x08, 0x01, 0x48, // Name = /H
				0x0A, 0x04, 0x12, 0x34, 0x56, 0x78, // Nonce
				0x0C, 0x02, 0x10, 0x00, // InterestLifetime = 4096
				0x22, 0x01, 0xD6, // HopLimit
				0x24, 0x04, 0xC0, 0xC1, 0xC2, 0xC3 // ApplicationParameters
		});
	
		private static readonly ArrayList fullCodedInterestV03Dump = new ArrayList(
				ILOG.J2CsMapping.Collections.Arrays.AsList(new Object[] { "name: /I",
									"minSuffixComponents: <none>",
									"maxSuffixComponents: <none>", "keyLocator: <none>",
									"exclude: <none>", "childSelector: <none>",
									"mustBeFresh: true", "nonce: 12345678",
									"lifetimeMilliseconds: 4096", "forwardingHint:",
									"  Preference: 256, Name: /H" }));
	
		private static ArrayList dumpInterest(Interest interest) {
			ArrayList result = new ArrayList();
			ILOG.J2CsMapping.Collections.Collections.Add(result,dump("name:", interest.getName().toUri()));
			ILOG.J2CsMapping.Collections.Collections.Add(result,dump(
							"minSuffixComponents:",
							(interest.getMinSuffixComponents() >= 0) ? (Object) (interest.getMinSuffixComponents()) : (Object) ("<none>")));
			ILOG.J2CsMapping.Collections.Collections.Add(result,dump(
							"maxSuffixComponents:",
							(interest.getMaxSuffixComponents() >= 0) ? (Object) (interest.getMaxSuffixComponents()) : (Object) ("<none>")));
			if (interest.getKeyLocator().getType() != net.named_data.jndn.KeyLocatorType.NONE) {
				if (interest.getKeyLocator().getType() == net.named_data.jndn.KeyLocatorType.KEY_LOCATOR_DIGEST)
					ILOG.J2CsMapping.Collections.Collections.Add(result,dump("keyLocator: KeyLocatorDigest:", interest
											.getKeyLocator().getKeyData().toHex()));
				else if (interest.getKeyLocator().getType() == net.named_data.jndn.KeyLocatorType.KEYNAME)
					ILOG.J2CsMapping.Collections.Collections.Add(result,dump("keyLocator: KeyName:", interest
											.getKeyLocator().getKeyName().toUri()));
				else
					ILOG.J2CsMapping.Collections.Collections.Add(result,dump("keyLocator: <unrecognized KeyLocatorType"));
			} else
				ILOG.J2CsMapping.Collections.Collections.Add(result,dump("keyLocator: <none>"));
			ILOG.J2CsMapping.Collections.Collections.Add(result,dump("exclude:", (interest.getExclude().size() > 0) ? interest
							.getExclude().toUri() : "<none>"));
			ILOG.J2CsMapping.Collections.Collections.Add(result,dump("childSelector:",
							(interest.getChildSelector() >= 0) ? (Object) (interest.getChildSelector())
									: (Object) ("<none>")));
			ILOG.J2CsMapping.Collections.Collections.Add(result,dump("mustBeFresh:", (interest.getMustBeFresh()) ? "true"
							: "false"));
			ILOG.J2CsMapping.Collections.Collections.Add(result,dump("nonce:", (interest.getNonce().size() == 0) ? "<none>"
							: interest.getNonce().toHex()));
			ILOG.J2CsMapping.Collections.Collections.Add(result,dump("lifetimeMilliseconds:",
							(interest.getInterestLifetimeMilliseconds() < 0) ? "<none>" : ""
									+ (long) interest.getInterestLifetimeMilliseconds()));
			if (interest.getForwardingHint().size() > 0) {
				ILOG.J2CsMapping.Collections.Collections.Add(result,dump("forwardingHint:"));
				for (int i = 0; i < interest.getForwardingHint().size(); ++i)
					ILOG.J2CsMapping.Collections.Collections.Add(result,dump("  Preference: "
											+ interest.getForwardingHint().get(i).getPreference()
											+ ", Name: "
											+ interest.getForwardingHint().get(i).getName().toUri()));
			} else
				ILOG.J2CsMapping.Collections.Collections.Add(result,dump("forwardingHint: <none>"));
			return result;
		}
	
		/// <summary>
		/// Return a copy of the strings array, removing any string that start with prefix.
		/// </summary>
		///
		private static ArrayList removeStartingWith(ArrayList strings, String prefix) {
			ArrayList result = new ArrayList();
			for (int i = 0; i < strings.Count; ++i) {
				if (!((String) strings[i]).StartsWith(prefix))
					ILOG.J2CsMapping.Collections.Collections.Add(result,strings[i]);
			}
	
			return result;
		}
	
		// ignoring nonce, check that the dumped interests are equal
		private static bool interestDumpsEqual(ArrayList dump1, ArrayList dump2) {
			String prefix = "nonce:";
			return ILOG.J2CsMapping.Collections.Arrays.Equals(ILOG.J2CsMapping.Collections.Collections.ToArray(removeStartingWith(dump1, prefix)),ILOG.J2CsMapping.Collections.Collections.ToArray(removeStartingWith(dump2, prefix)));
		}
	
		private static Interest createFreshInterest() {
			Interest freshInterest = new Interest(new Name("/ndn/abc"))
					.setMustBeFresh(false).setMinSuffixComponents(4)
					.setMaxSuffixComponents(6)
					.setInterestLifetimeMilliseconds(30000).setChildSelector(1)
					.setMustBeFresh(true);
			freshInterest.getKeyLocator()
					.setType(net.named_data.jndn.KeyLocatorType.KEY_LOCATOR_DIGEST);
			freshInterest.getKeyLocator().setKeyData(
					new Blob(new int[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
							0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
							0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
							0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F }));
			freshInterest.getExclude().appendComponent(new Name("abc").get(0))
					.appendAny();
			freshInterest.getForwardingHint().add(1, new Name("/A"));
	
			return freshInterest;
		}
	
		private Interest referenceInterest;
	
		public void setUp() {
			referenceInterest = new Interest();
			try {
				referenceInterest.wireDecode(new Blob(codedInterest, false));
			} catch (EncodingException ex) {
				// We don't expect this to happen.
				referenceInterest = null;
			}
		}
	
		public void testDump() {
			// see if the dump format is the same as we expect
			ArrayList decodedDump = dumpInterest(referenceInterest);
			Assert.AssertArrayEquals("Initial dump does not have expected format",
					ILOG.J2CsMapping.Collections.Collections.ToArray(initialDump), ILOG.J2CsMapping.Collections.Collections.ToArray(decodedDump));
		}
	
		public void testRedecode() {
			// check that we encode and decode correctly
			Blob encoding = referenceInterest.wireEncode();
			Interest reDecodedInterest = new Interest();
			try {
				reDecodedInterest.wireDecode(encoding);
			} catch (EncodingException ex) {
				Assert.Fail("Can't decode reDecodedInterest");
			}
			ArrayList redecodedDump = dumpInterest(reDecodedInterest);
			Assert.AssertArrayEquals("Re-decoded interest does not match original",
					ILOG.J2CsMapping.Collections.Collections.ToArray(initialDump), ILOG.J2CsMapping.Collections.Collections.ToArray(redecodedDump));
		}
	
		public void testRedecodeImplicitDigestExclude() {
			// Check that we encode and decode correctly with an implicit digest exclude.
			Interest interest = new Interest(new Name("/A"));
			interest.getExclude()
					.appendComponent(
							new Name(
									"/sha256digest="
											+ "000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f")
									.get(0));
			ArrayList dump = dumpInterest(interest);
	
			Blob encoding = interest.wireEncode();
			Interest reDecodedInterest = new Interest();
			try {
				reDecodedInterest.wireDecode(encoding);
			} catch (EncodingException ex) {
				Assert.Fail("Can't decode reDecodedInterest");
			}
			ArrayList redecodedDump = dumpInterest(reDecodedInterest);
			Assert.AssertTrue("Re-decoded interest does not match original",
					interestDumpsEqual(dump, redecodedDump));
		}
	
		public void testCreateFresh() {
			Interest freshInterest = createFreshInterest();
			ArrayList freshDump = dumpInterest(freshInterest);
			Assert.AssertTrue("Fresh interest does not match original",
					interestDumpsEqual(initialDump, freshDump));
	
			Interest reDecodedFreshInterest = new Interest();
			try {
				reDecodedFreshInterest.wireDecode(freshInterest.wireEncode());
			} catch (EncodingException ex) {
				Assert.Fail("Can't decode reDecodedFreshInterest");
			}
			ArrayList reDecodedFreshDump = dumpInterest(reDecodedFreshInterest);
	
			Assert.AssertTrue("Redecoded fresh interest does not match original",
					interestDumpsEqual(freshDump, reDecodedFreshDump));
		}
	
		public void testNoSelectorsMustBeFresh() {
			Interest interest = new Interest();
			interest.wireDecode(new Blob(codedInterestNoSelectors, false));
			Assert.AssertEquals("MustBeFresh should be false if no selectors", false,
					interest.getMustBeFresh());
		}
	
		public void testCopyConstructor() {
			Interest interest = new Interest(referenceInterest);
			Assert.AssertTrue(
					"Interest constructed as deep copy does not match original",
					interestDumpsEqual(dumpInterest(interest),
							dumpInterest(referenceInterest)));
		}
	
		public void testEmptyNonce() {
			// make sure a freshly created interest has no nonce
			Interest freshInterest = createFreshInterest();
			Assert.AssertTrue("Freshly created interest should not have a nonce",
					freshInterest.getNonce().isNull());
		}
	
		public void testSetRemovesNonce() {
			// Ensure that changing a value on an interest clears the nonce.
			Assert.AssertFalse(referenceInterest.getNonce().isNull());
			Interest interest = new Interest(referenceInterest);
			// Change a child object.
			interest.getExclude().clear();
			Assert.AssertTrue("Interest should not have a nonce after changing fields",
					interest.getNonce().isNull());
		}
	
		public void testRefreshNonce() {
			Interest interest = new Interest(referenceInterest);
			Blob oldNonce = interest.getNonce();
			Assert.AssertEquals(4, oldNonce.size());
	
			interest.refreshNonce();
			Assert.AssertEquals("The refreshed nonce should be the same size",
					oldNonce.size(), interest.getNonce().size());
			Assert.AssertFalse("The refreshed nonce should be different", interest
					.getNonce().equals(oldNonce));
		}
	
		public void testExcludeMatches() {
			Exclude exclude = new Exclude();
			exclude.appendComponent(new Name("%00%02").get(0));
			exclude.appendAny();
			exclude.appendComponent(new Name("%00%20").get(0));
	
			Name.Component component;
			component = new Name("%00%01").get(0);
			Assert.AssertFalse(component.toEscapedString() + " should not match "
					+ exclude.toUri(), exclude.matches(component));
			component = new Name("%00%0F").get(0);
			Assert.AssertTrue(
					component.toEscapedString() + " should match "
							+ exclude.toUri(), exclude.matches(component));
			component = new Name("%00%21").get(0);
			Assert.AssertFalse(component.toEscapedString() + " should not match "
					+ exclude.toUri(), exclude.matches(component));
		}
	
		public void testVerifyDigestSha256() {
			// Create a KeyChain but we don't need to add keys.
			MemoryIdentityStorage identityStorage = new MemoryIdentityStorage();
			MemoryPrivateKeyStorage privateKeyStorage = new MemoryPrivateKeyStorage();
			KeyChain keyChain = new KeyChain(new IdentityManager(identityStorage,
					privateKeyStorage),
					new SelfVerifyPolicyManager(identityStorage));
	
			Interest interest = new Interest(new Name("/test/signed-interest"));
			keyChain.signWithSha256(interest);
	
			VerifyInterestCounter counter = new VerifyInterestCounter();
			keyChain.verifyInterest(interest, counter, counter);
			Assert.AssertEquals("Signature verification failed", 0,
					counter.onValidationFailedCallCount_);
			Assert.AssertEquals("Verification callback was not used", 1,
					counter.onVerifiedCallCount_);
		}
	
		public void testMatchesData() {
			Interest interest = new Interest(new Name("/A"));
			interest.setMinSuffixComponents(2);
			interest.setMaxSuffixComponents(2);
			interest.getKeyLocator().setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
			interest.getKeyLocator().setKeyName(new Name("/B"));
			interest.getExclude().appendComponent(new Name.Component("J"));
			interest.getExclude().appendAny();
	
			Data data = new Data(new Name("/A/D"));
			Sha256WithRsaSignature signature = new Sha256WithRsaSignature();
			signature.getKeyLocator().setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
			signature.getKeyLocator().setKeyName(new Name("/B"));
			data.setSignature(signature);
			Assert.AssertEquals(true, interest.matchesData(data));
	
			// Check violating MinSuffixComponents.
			Data data1 = new Data(data);
			data1.setName(new Name("/A"));
			Assert.AssertEquals(false, interest.matchesData(data1));
	
			Interest interest1 = new Interest(interest);
			interest1.setMinSuffixComponents(1);
			Assert.AssertEquals(true, interest1.matchesData(data1));
	
			// Check violating MaxSuffixComponents.
			Data data2 = new Data(data);
			data2.setName(new Name("/A/E/F"));
			Assert.AssertEquals(false, interest.matchesData(data2));
	
			Interest interest2 = new Interest(interest);
			interest2.setMaxSuffixComponents(3);
			Assert.AssertEquals(true, interest2.matchesData(data2));
	
			// Check violating PublisherPublicKeyLocator.
			Data data3 = new Data(data);
			Sha256WithRsaSignature signature3 = new Sha256WithRsaSignature();
			signature3.getKeyLocator().setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
			signature3.getKeyLocator().setKeyName(new Name("/G"));
			data3.setSignature(signature3);
			Assert.AssertEquals(false, interest.matchesData(data3));
	
			Interest interest3 = new Interest(interest);
			interest3.getKeyLocator().setType(net.named_data.jndn.KeyLocatorType.KEYNAME);
			interest3.getKeyLocator().setKeyName(new Name("/G"));
			Assert.AssertEquals(true, interest3.matchesData(data3));
	
			Data data4 = new Data(data);
			data4.setSignature(new DigestSha256Signature());
			Assert.AssertEquals(false, interest.matchesData(data4));
	
			Interest interest4 = new Interest(interest);
			interest4.setKeyLocator(new KeyLocator());
			Assert.AssertEquals(true, interest4.matchesData(data4));
	
			// Check violating Exclude.
			Data data5 = new Data(data);
			data5.setName(new Name("/A/J"));
			Assert.AssertEquals(false, interest.matchesData(data5));
	
			Interest interest5 = new Interest(interest);
			interest5.getExclude().clear();
			interest5.getExclude().appendComponent(new Name.Component("K"));
			interest5.getExclude().appendAny();
			Assert.AssertEquals(true, interest5.matchesData(data5));
	
			// Check violating Name.
			Data data6 = new Data(data);
			data6.setName(new Name("/H/I"));
			Assert.AssertEquals(false, interest.matchesData(data6));
	
			Data data7 = new Data(data);
			data7.setName(new Name("/A/B"));
	
			Interest interest7 = new Interest(
					new Name(
							"/A/B/sha256digest="
									+ "54008e240a7eea2714a161dfddf0dd6ced223b3856e9da96792151e180f3b128"));
			Assert.AssertEquals(true, interest7.matchesData(data7));
	
			// Check violating the implicit digest.
			Interest interest7b = new Interest(new Name(
					"/A/B/%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00"
							+ "%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00"));
			Assert.AssertEquals(false, interest7b.matchesData(data7));
	
			// Check excluding the implicit digest.
			Interest interest8 = new Interest(new Name("/A/B"));
			interest8.getExclude().appendComponent(interest7.getName().get(2));
			Assert.AssertEquals(false, interest8.matchesData(data7));
		}
	
		public void testInterestFilterMatching() {
			// From ndn-cxx interest.t.cpp.
			Assert.AssertEquals(true, new InterestFilter("/a").doesMatch(new Name("/a/b")));
			Assert.AssertEquals(true,
					new InterestFilter("/a/b").doesMatch(new Name("/a/b")));
			Assert.AssertEquals(false,
					new InterestFilter("/a/b/c").doesMatch(new Name("/a/b")));
	
			Assert.AssertEquals(true,
					new InterestFilter("/a", "<b>").doesMatch(new Name("/a/b")));
			Assert.AssertEquals(false,
					new InterestFilter("/a/b", "<b>").doesMatch(new Name("/a/b")));
	
			Assert.AssertEquals(false,
					new InterestFilter("/a/b", "<c>")
							.doesMatch(new Name("/a/b/c/d")));
			Assert.AssertEquals(false,
					new InterestFilter("/a/b", "<b>")
							.doesMatch(new Name("/a/b/c/b")));
			Assert.AssertEquals(true,
					new InterestFilter("/a/b", "<>*<b>").doesMatch(new Name(
							"/a/b/c/b")));
	
			Assert.AssertEquals(false,
					new InterestFilter("/a", "<b>").doesMatch(new Name("/a/b/c/d")));
			Assert.AssertEquals(true,
					new InterestFilter("/a", "<b><>*").doesMatch(new Name(
							"/a/b/c/d")));
			Assert.AssertEquals(true,
					new InterestFilter("/a", "<b><>*").doesMatch(new Name("/a/b")));
			Assert.AssertEquals(false,
					new InterestFilter("/a", "<b><>+").doesMatch(new Name("/a/b")));
			Assert.AssertEquals(true,
					new InterestFilter("/a", "<b><>+")
							.doesMatch(new Name("/a/b/c")));
		}
	
		public void testSetApplicationParameters() {
			Interest interest = new Interest("/ndn");
			Assert.AssertTrue(!interest.hasApplicationParameters());
			Blob applicationParameters = new Blob(
					toBuffer(new int[] { 0x23, 0x00 }), false);
			interest.setApplicationParameters(applicationParameters);
			Assert.AssertTrue(interest.hasApplicationParameters());
			Assert.AssertTrue(interest.getApplicationParameters().equals(
					applicationParameters));
	
			Interest decodedInterest = new Interest();
			decodedInterest.wireDecode(interest.wireEncode());
			Assert.AssertTrue(decodedInterest.getApplicationParameters().equals(
					applicationParameters));
	
			interest.setApplicationParameters(new Blob());
			Assert.AssertTrue(!interest.hasApplicationParameters());
		}
	
		public void testAppendParametersDigest() {
			Name name = new Name("/local/ndn/prefix");
			Interest interest = new Interest(name);
	
			Assert.AssertTrue(!interest.hasApplicationParameters());
			// No application parameters yet, so it should do nothing.
			interest.appendParametersDigestToName();
			Assert.AssertEquals("/local/ndn/prefix", interest.getName().toUri());
	
			Blob applicationParameters = new Blob(toBuffer(new int[] { 0x23, 0x01,
					0xC0 }), false);
			interest.setApplicationParameters(applicationParameters);
			Assert.AssertTrue(interest.hasApplicationParameters());
			interest.appendParametersDigestToName();
			Assert.AssertEquals(name.size() + 1, interest.getName().size());
			Assert.AssertTrue(interest.getName().getPrefix(-1).equals(name));
			int SHA256_LENGTH = 32;
			Assert.AssertEquals(SHA256_LENGTH, interest.getName().get(-1).getValue()
					.size());
	
			Assert.AssertEquals(
					interest.getName().toUri(),
					"/local/ndn/prefix/"
							+ "params-sha256=a16cc669b4c9ef6801e1569488513f9523ffb28a39e53aa6e11add8d00a413fc");
		}
	
		public void testDecodeV03AsV02() {
			Interest interest1 = new Interest();
			interest1.wireDecode(new Blob(simpleCodedInterestV03, false));
	
			ArrayList dump1 = dumpInterest(interest1);
			Assert.AssertArrayEquals(
					"Decoded simpleCodedInterestV03 does not match the dump",
					ILOG.J2CsMapping.Collections.Collections.ToArray(dump1), ILOG.J2CsMapping.Collections.Collections.ToArray(simpleCodedInterestV03Dump));
	
			Interest interest2 = new Interest();
			interest2.wireDecode(new Blob(fullCodedInterestV03, false));
	
			ArrayList dump2 = dumpInterest(interest2);
			Assert.AssertArrayEquals(
					"Decoded fullCodedInterestV03 does not match the dump",
					ILOG.J2CsMapping.Collections.Collections.ToArray(dump2), ILOG.J2CsMapping.Collections.Collections.ToArray(fullCodedInterestV03Dump));
		}
	}
}
