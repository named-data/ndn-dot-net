// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
//
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2019 Regents of the University of California.
/// </summary>
///
namespace net.named_data.jndn.tests.unit_tests {
	
	using ILOG.J2CsMapping.Collections;
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using net.named_data.jndn;
	using net.named_data.jndn.sync.detail;
	using net.named_data.jndn.util;
	
	public class TestInvertibleBloomLookupTable {
		public void testEqual() {
			int size = 10;
	
			InvertibleBloomLookupTable iblt1 = new InvertibleBloomLookupTable(size);
			InvertibleBloomLookupTable iblt2 = new InvertibleBloomLookupTable(size);
	
			Assert.AssertTrue(iblt1.equals(iblt2));
	
			String prefix = new Name("/test/memphis").appendNumber(1).toUri();
			long newHash = net.named_data.jndn.util.Common.murmurHash3(11,
					new Blob(prefix).getImmutableArray());
			iblt1.insert(newHash);
			iblt2.insert(newHash);
			Assert.AssertTrue(iblt1.equals(iblt2));
	
			Name ibfName1 = new Name("/sync");
			Name ibfName2 = new Name("/sync");
			ibfName1.append(iblt1.encode());
			ibfName2.append(iblt2.encode());
			Assert.AssertTrue(ibfName1.equals(ibfName2));
		}
	
		public void testNameAppendAndExtract() {
			int size = 10;
	
			InvertibleBloomLookupTable iblt = new InvertibleBloomLookupTable(size);
			String prefix = new Name("/test/memphis").appendNumber(1).toUri();
			long newHash = net.named_data.jndn.util.Common.murmurHash3(11,
					new Blob(prefix).getImmutableArray());
			iblt.insert(newHash);
	
			Blob expectedEncoding = new Blob(new int[] { 0x78, 0xda, 0x63, 0x64,
					0x60, 0x60, 0xd8, 0x55, 0xb5, 0xfc, 0x5b, 0xb2, 0xef, 0xe2,
					0x6c, 0x06, 0x0a, 0x00, 0x23, 0x1d, 0xcd, 0x01, 0x00, 0x65,
					0x29, 0x0d, 0xb1 });
	
			Name ibltName = new Name("sync");
			Blob encodedIblt = iblt.encode();
			Assert.AssertTrue(encodedIblt.equals(expectedEncoding));
			ibltName.append(encodedIblt);
	
			InvertibleBloomLookupTable received = new InvertibleBloomLookupTable(
					size);
			received.initialize(ibltName.get(-1).getValue());
	
			Assert.AssertTrue(iblt.equals(received));
	
			InvertibleBloomLookupTable receivedDifferentSize = new InvertibleBloomLookupTable(
					20);
			try {
				receivedDifferentSize.initialize(ibltName.get(-1).getValue());
				Assert.Fail("Did not throw the expected exception");
			} catch (AssertionError ex) {
			} catch (Exception ex_0) {
				Assert.Fail("Did not throw the expected exception");
			}
		}
	
		public void testCopyInsertErase() {
			int size = 10;
	
			InvertibleBloomLookupTable iblt1 = new InvertibleBloomLookupTable(size);
	
			String prefix = new Name("/test/memphis").appendNumber(1).toUri();
			long hash1 = net.named_data.jndn.util.Common.murmurHash3(11,
					new Blob(prefix).getImmutableArray());
			iblt1.insert(hash1);
	
			InvertibleBloomLookupTable iblt2 = new InvertibleBloomLookupTable(iblt1);
			iblt2.erase(hash1);
			prefix = new Name("/test/memphis").appendNumber(2).toUri();
			long hash3 = net.named_data.jndn.util.Common.murmurHash3(11,
					new Blob(prefix).getImmutableArray());
			iblt2.insert(hash3);
	
			iblt1.erase(hash1);
			prefix = new Name("/test/memphis").appendNumber(5).toUri();
			long hash5 = net.named_data.jndn.util.Common.murmurHash3(11,
					new Blob(prefix).getImmutableArray());
			iblt1.insert(hash5);
	
			iblt2.erase(hash3);
			iblt2.insert(hash5);
	
			Assert.AssertTrue(iblt1.equals(iblt2));
		}
	
		public void testHigherSequence() {
			// This is the case where we can't recognize if the received IBF has a higher
			// sequence number. This is relevant to the full sync case.
			int size = 10;
	
			InvertibleBloomLookupTable ownIblt = new InvertibleBloomLookupTable(
					size);
			InvertibleBloomLookupTable receivedIblt = new InvertibleBloomLookupTable(
					size);
	
			String prefix = new Name("/test/memphis").appendNumber(3).toUri();
			long hash1 = net.named_data.jndn.util.Common.murmurHash3(11,
					new Blob(prefix).getImmutableArray());
			ownIblt.insert(hash1);
	
			String prefix2 = new Name("/test/memphis").appendNumber(4).toUri();
			long hash2 = net.named_data.jndn.util.Common.murmurHash3(11,
					new Blob(prefix2).getImmutableArray());
			receivedIblt.insert(hash2);
	
			InvertibleBloomLookupTable diff = ownIblt.difference(receivedIblt);
			HashedSet<Int64> positive = new HashedSet<Int64>();
			HashedSet<Int64> negative = new HashedSet<Int64>();
	
			Assert.AssertTrue(diff.listEntries(positive, negative));
			Assert.AssertEquals(1, positive.Count);
			Assert.AssertTrue(((Int64)ILOG.J2CsMapping.Collections.Collections.ToArray(positive)[0]) == hash1);
	
			Assert.AssertEquals(1, negative.Count);
			Assert.AssertTrue(((Int64)ILOG.J2CsMapping.Collections.Collections.ToArray(negative)[0]) == hash2);
		}
	
		public void testDifference() {
			int size = 10;
	
			InvertibleBloomLookupTable ownIblt = new InvertibleBloomLookupTable(
					size);
	
			InvertibleBloomLookupTable receivedIblt = new InvertibleBloomLookupTable(
					ownIblt);
	
			InvertibleBloomLookupTable diff = ownIblt.difference(receivedIblt);
	
			// Non-empty positive means we have some elements that the other doesn't.
			HashedSet<Int64> positive = new HashedSet<Int64>();
			HashedSet<Int64> negative = new HashedSet<Int64>();
	
			Assert.AssertTrue(diff.listEntries(positive, negative));
			Assert.AssertEquals(0, positive.Count);
			Assert.AssertEquals(0, negative.Count);
	
			String prefix = new Name("/test/memphis").appendNumber(1).toUri();
			long newHash = net.named_data.jndn.util.Common.murmurHash3(11,
					new Blob(prefix).getImmutableArray());
			ownIblt.insert(newHash);
	
			diff = ownIblt.difference(receivedIblt);
			Assert.AssertTrue(diff.listEntries(positive, negative));
			Assert.AssertEquals(1, positive.Count);
			Assert.AssertEquals(0, negative.Count);
	
			prefix = new Name("/test/csu").appendNumber(1).toUri();
			newHash = net.named_data.jndn.util.Common.murmurHash3(11, new Blob(prefix).getImmutableArray());
			receivedIblt.insert(newHash);
	
			diff = ownIblt.difference(receivedIblt);
			Assert.AssertTrue(diff.listEntries(positive, negative));
			Assert.AssertEquals(1, positive.Count);
			Assert.AssertEquals(1, negative.Count);
		}
	
		public void testDifferenceBwOversizedIblts() {
			// Insert 50 elements into an IBLT of size 10. Then check that we can still
			// list the difference even though we can't list the IBLT itself.
	
			int size = 10;
	
			InvertibleBloomLookupTable ownIblt = new InvertibleBloomLookupTable(
					size);
	
			for (int i = 0; i < 50; ++i) {
				String prefix = new Name("/test/memphis" + i).appendNumber(1)
						.toUri();
				long newHash = net.named_data.jndn.util.Common.murmurHash3(11,
						new Blob(prefix).getImmutableArray());
				ownIblt.insert(newHash);
			}
	
			InvertibleBloomLookupTable receivedIblt = new InvertibleBloomLookupTable(
					ownIblt);
	
			String prefix_0 = new Name("/test/ucla").appendNumber(1).toUri();
			long newHash_1 = net.named_data.jndn.util.Common.murmurHash3(11,
					new Blob(prefix_0).getImmutableArray());
			ownIblt.insert(newHash_1);
	
			InvertibleBloomLookupTable diff = ownIblt.difference(receivedIblt);
	
			HashedSet<Int64> positive = new HashedSet<Int64>();
			HashedSet<Int64> negative = new HashedSet<Int64>();
			Assert.AssertTrue(diff.listEntries(positive, negative));
			Assert.AssertEquals(1, positive.Count);
			Assert.AssertTrue(newHash_1 == ((Int64)ILOG.J2CsMapping.Collections.Collections.ToArray(positive)[0]));
			Assert.AssertEquals(0, negative.Count);
	
			Assert.AssertTrue(!ownIblt.listEntries(positive, negative));
			Assert.AssertTrue(!receivedIblt.listEntries(positive, negative));
		}
	
		// This is to force an import of net.named_data.jndn.util.
		private static Common dummyCommon_ = new Common();
	}
}
